<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alexritian.github.io</id>
    <title>Note My Life</title>
    <updated>2023-02-17T07:33:38.260Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alexritian.github.io"/>
    <link rel="self" href="https://alexritian.github.io/atom.xml"/>
    <subtitle>随便写写，胡乱记记</subtitle>
    <logo>https://alexritian.github.io/images/avatar.png</logo>
    <icon>https://alexritian.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Note My Life</rights>
    <entry>
        <title type="html"><![CDATA[RASA初体验---构建一个人工智障]]></title>
        <id>https://alexritian.github.io/post/rasa-chu-ti-yan-gou-jian-yi-ge-ren-gong-zhi-zhang/</id>
        <link href="https://alexritian.github.io/post/rasa-chu-ti-yan-gou-jian-yi-ge-ren-gong-zhi-zhang/">
        </link>
        <updated>2023-02-17T07:10:02.000Z</updated>
        <summary type="html"><![CDATA[<p>使用RASA构建一个聊天机器人demo</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用RASA构建一个聊天机器人demo</p>
<!-- more -->
<h1 id="准备工作">准备工作</h1>
<blockquote>
<p>[!attention]<br>
需要docker环境，如果没有docker，请先安装好docker。</p>
</blockquote>
<h2 id="制作镜像">制作镜像</h2>
<blockquote>
<p>[!tip]<br>
因为要使用jieba分词，官方的镜像没有预装jieba分词的模块，所以需要制作一个带有jieba分词的docker镜像</p>
</blockquote>
<ul>
<li>编辑 <code>Dockerfile</code> 文件</li>
</ul>
<pre><code class="language-yaml">FROM rasa/rasa:latest-full

USER root

RUN pip install jieba

USER 1001
</code></pre>
<ul>
<li>build镜像</li>
</ul>
<pre><code class="language-shell">docker build -t rasa-jieba .
</code></pre>
<blockquote>
<p>[!note]<br>
执行命令和 <code>Dockerfile</code> 不在同一个目录，命令中的 <code>.</code> 需要替换为 <code>Dockerfile</code> 文件的路径</p>
</blockquote>
<h2 id="下载jieba分词词典">下载jieba分词词典</h2>
<ul>
<li><a href="https://github.com/fxsjy/jieba">jieba词典</a> （我使用的是 <a href="https://github.com/fxsjy/jieba/blob/master/extra_dict/dict.txt.big">dict.txt.big</a> )</li>
</ul>
<h1 id="初始化模型">初始化模型</h1>
<pre><code class="language-shell">docker run -it -v /data/ai/rasa_data/:/app rasa-jieba init
</code></pre>
<blockquote>
<p>[!tip]<br>
<code>/app</code> 是rasa默认使用的目录，模型相关文件都在这个目录</p>
</blockquote>
<h1 id="编辑模型文件">编辑模型文件</h1>
<blockquote>
<p>[!tip]<br>
<code>RASA</code> 默认支持英文和德文，如果要使用中文需要对初始化的模型文件进行修改</p>
</blockquote>
<ul>
<li><code>data/nul.yml</code></li>
</ul>
<p>这是训练数据，<code>intent</code> 是用户意图，<code>examples</code> 是训练数据</p>
<pre><code class="language-yaml">version: &quot;3.0&quot;

nlu:
- intent: greet
  examples: |
    - 你好
    - 您好
    - 早上好
    - 下午好

- intent: inform
  examples: |
    - 我想订一张去北京的机票
    - 明天北京天气怎么样
    - 北京有哪些好玩的地方
    - 我要预定一个酒店

- intent: book_flight
  examples: |
    - 我要订一张从[上海](origin)到[北京](destination)的机票
    - 我要预定明天从[南京](origin)到[广州](destination)的航班
    - 我想要从[北京](origin)飞往[香港](destination)
    - 我需要订一张从[深圳](origin)到[上海](destination)的机票
    - 我想订一张从[杭州](origin)到[成都](destination)的航班
    - 我想买一张从[重庆](origin)到[西安](destination)的机票
    - 我要预订[上海](destination)到[北京](origin)的机票
    - 我需要乘坐[深圳](origin)到[北京](destination)的航班
    - 我想要订一张从[上海](origin)到[成都](destination)的机票
    - 请帮我预订从[广州](origin)飞往[北京](destination)的机票

- intent: check_weather
  examples: |
    - 明天[北京](location)的天气怎么样？
    - [上海](location)会下雨吗？
    - [广州](location)最高温度会是多少？

- intent: recommend_place
  examples: |
    - 北京有哪些好玩的地方？
    - 能给我推荐一些适合家庭旅游的地方吗？
    - 哪里有好吃的北京烤鸭？
  
- intent: book_hotel
  examples: |
    - 我要预订一间酒店
    - 给我预定一间在[北京](location)的酒店
    - [上海](location)有哪些不错的酒店？

- intent: bot_challenge
  examples: |
    - 你是机器人吗？
    - 你是人工智能吗？
    - 你是人吗？
    - 你是人类吗？

entity:
- location
- origin
- destination
</code></pre>
<ul>
<li><code>domain.yml</code></li>
</ul>
<p><code>responses</code> 是bot反馈内容</p>
<pre><code class="language-yaml">version: &quot;3.0&quot;

intents:
  - greet
  - inform
  - book_flight
  - check_weather
  - recommend_place
  - book_hotel
  - bot_challenge

responses:
  utter_greet:
  - text: &quot;你好，我是rasa-jieba&quot;

  utter_give_inform:
  - text: &quot;我将搜索相关信息,推荐去[北京]游玩&quot;

  utter_ask_if_need_book_flight:
  - text: &quot;是否需要我帮您订机票&quot;

  utter_ask_name:
  - text: &quot;请体提供您的姓名&quot;

  utter_give_weather:
  - text: &quot;天气晴朗&quot;

  utter_goodbye:
  - text: &quot;Bye&quot;

  utter_iamabot:
  - text: &quot;我是个人工智障.&quot;

session_config:
session_expiration_time: 60
carry_over_slots_to_new_session: true
</code></pre>
<ul>
<li><code>data/stories.yml</code></li>
</ul>
<p>客户故事文件，定义 <code>story</code></p>
<pre><code class="language-yaml">version: &quot;3.0&quot;

stories:

- story: greet and bot challenge
  steps:
  - intent: greet
  - action: utter_greet
  - intent: bot_challenge
  - action: utter_iamabot

- story: ask weather
  steps:
  - intent: greet
  - action: utter_greet
  - intent: check_weather
  - action: utter_give_weather

- story: book flight
  steps:
  - intent: greet
  - action: utter_greet
  - intent: recommend_place
  - action: utter_give_inform
  - action: utter_ask_if_need_book_flight
</code></pre>
<ul>
<li><code>data/rules.yml</code></li>
</ul>
<pre><code class="language-yaml">version: &quot;3.0&quot;

rules:

- rule: Say 'I am a bot' anytime the user challenges
  steps:
  - intent: bot_challenge
  - action: utter_iamabot

- rule: boot flight anytime
  steps:
  - intent: book_flight
  - action: utter_ask_name
</code></pre>
<ul>
<li><code>config.yml</code></li>
</ul>
<pre><code class="language-yaml">language: &quot;zh&quot;

pipeline:
  - name: JiebaTokenizer
    dictionary_path: &quot;data/dict.txt.big&quot;
  - name: EntitySynonymMapper
  - name: RegexFeaturizer
  - name: CountVectorsFeaturizer
  - name: CountVectorsFeaturizer
    analyzer: &quot;char_wb&quot;
    min_ngram: 1
    max_ngram: 4
  - name: DIETClassifier
    epochs: 100
  - name: ResponseSelector
    epochs: 100
  - name: FallbackClassifier
    threshold: 0.3
    ambiguity_threshold: 0.1

policies:
# # No configuration for policies was provided. The following default policies were used to train your model.
# # If you'd like to customize them, uncomment and adjust the policies.
# # See https://rasa.com/docs/rasa/policies for more information.
# - name: MemoizationPolicy
# - name: RulePolicy
# - name: UnexpecTEDIntentPolicy
# max_history: 5
# epochs: 100
# - name: TEDPolicy
# max_history: 5
# epochs: 100
# constrain_similarities: true
</code></pre>
<blockquote>
<p>[!tip]<br>
<code>JiebaTokenizer</code> 是jieba中文分词器<br>
<code>dictionary_path</code> 指定词典文件，将其替换为前面下载的词典文件</p>
</blockquote>
<h1 id="训练模型">训练模型</h1>
<pre><code class="language-shell">docker run -it -v /data/ai/rasa_data/:/app rasa-jieba train
</code></pre>
<h1 id="与模型对话">与模型对话</h1>
<pre><code class="language-shell">docker run -it -v /data/ai/rasa_data/:/app -e LOG_LEVEL=DEBUG -p 5005:5005 rasa-jieba shell
</code></pre>
<blockquote>
<p>[!tip]<br>
<code>-e LOG_LEVEL=DEBUG</code> 开启debug级别的日志，如果不需要debug日志，可以去掉。</p>
</blockquote>
<h1 id="结语">结语</h1>
<p>到此一个非常非常非常简单的聊天机器人就构建好了，迈出了第一步。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用Docker启动TansorFlow]]></title>
        <id>https://alexritian.github.io/post/shi-yong-docker-qi-dong-tansorflow/</id>
        <link href="https://alexritian.github.io/post/shi-yong-docker-qi-dong-tansorflow/">
        </link>
        <updated>2023-02-14T05:43:46.000Z</updated>
        <summary type="html"><![CDATA[<p>使用Docker部署tansorFlow和juypter server</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用Docker部署tansorFlow和juypter server</p>
<!-- more -->
<h1 id="下载-tensorflow-docker-映像">下载 TensorFlow Docker 映像</h1>
<p>官方 TensorFlow Docker 映像位于 <a href="https://hub.docker.com/r/tensorflow/tensorflow/">tensorflow/tensorflow</a> Docker Hub 代码库中。映像版本按照以下格式进行<a href="https://hub.docker.com/r/tensorflow/tensorflow/tags/">标记</a>：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>latest</code></td>
<td>TensorFlow CPU 二进制映像的最新版本。（默认版本）</td>
</tr>
<tr>
<td><code>nightly</code></td>
<td>TensorFlow 映像的每夜版。（不稳定）</td>
</tr>
<tr>
<td><em><code>version</code></em></td>
<td>指定 TensorFlow 二进制映像的版本，例如：2.1.0</td>
</tr>
<tr>
<td><code>devel</code></td>
<td>TensorFlow <code>master</code> 开发环境的每夜版。包含 TensorFlow 源代码。</td>
</tr>
<tr>
<td><code>custom-op</code></td>
<td>用于开发 TF 自定义操作的特殊实验性映像。详见<a href="https://github.com/tensorflow/custom-op">此处</a>。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>每个基本标记都有会添加或更改功能的变体：</p>
<table>
<thead>
<tr>
<th>标记变体</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><em><code>tag</code></em><code>-gpu</code></td>
<td>支持 GPU 的指定标记版本。（<a href="https://tensorflow.google.cn/install/docker?hl=zh-cn#gpu_support">详见下文</a>）</td>
</tr>
<tr>
<td><em><code>tag</code></em><code>-jupyter</code></td>
<td>针对 Jupyter 的指定标记版本（包含 TensorFlow 教程笔记本）</td>
</tr>
<tr>
<td>您可以一次使用多个变体。例如，以下命令会将 TensorFlow 版本映像下载到计算机上：</td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-shell">docker pull tensorflow/tensorflow                     # latest stable release
docker pull tensorflow/tensorflow:devel-gpu           # nightly dev release w/ GPU support
</code></pre>
<h1 id="启动镜像">启动镜像</h1>
<pre><code class="language-shell">docker run -d -p 8888:8888 tensorflow/tensorflow:latest-jupyter
</code></pre>
<blockquote>
<p>[!tip]<br>
此命令会启动tensorflow和jupyter server， 8888端口为jupyter server端口</p>
</blockquote>
<h1 id="登陆jupter-server">登陆jupter server</h1>
<p>查看镜像启动后的日志 , 通过 日志用的 url访问jupyter.</p>
<pre><code>[I 03:06:03.714 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret
[I 03:06:03.949 NotebookApp] Serving notebooks from local directory: /tf
[I 03:06:03.949 NotebookApp] Jupyter Notebook 6.4.5 is running at:
[I 03:06:03.949 NotebookApp] http://271621135e5c:8888/?token=&lt;token&gt;
[I 03:06:03.949 NotebookApp]  or http://127.0.0.1:8888/?token=f&lt;token&gt;
[I 03:06:03.949 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
[C 03:06:03.952 NotebookApp] 
    
    To access the notebook, open this file in a browser:
        file:///root/.local/share/jupyter/runtime/nbserver-1-open.html
    Or copy and paste one of these URLs:
        http://271621135e5c:8888/?token=f&lt;token&gt;
     or http://127.0.0.1:8888/?token=f&lt;token&gt;
</code></pre>
<p>![[Pasted image 20230214111125.png]]</p>
<p>http://127.0.0.1:8888/?token=f7fb7f4a869330c9bc7e10c06c9561bf3ffc78598c2648f1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建简单的openstack体验环境]]></title>
        <id>https://alexritian.github.io/post/da-jian-jian-dan-de-openstack-ti-yan-huan-jing/</id>
        <link href="https://alexritian.github.io/post/da-jian-jian-dan-de-openstack-ti-yan-huan-jing/">
        </link>
        <updated>2023-02-01T08:44:06.000Z</updated>
        <summary type="html"><![CDATA[<p>使用 <code>kolla-ansible</code> 搭建一个极简的openstack环境，体验一下openstack。本文是参考 <a href="https://docs.openstack.org/kolla-ansible/latest/user/quickstart.html">kolla-ansible官方文档</a> 进行搭建</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用 <code>kolla-ansible</code> 搭建一个极简的openstack环境，体验一下openstack。本文是参考 <a href="https://docs.openstack.org/kolla-ansible/latest/user/quickstart.html">kolla-ansible官方文档</a> 进行搭建</p>
<!-- more -->
<p>需要提前了解 <strong>docker</strong> 和 <strong>ansible</strong> 。</p>
<h1 id="准备">准备</h1>
<p>一台物理机或者虚拟机，本着节约资源的目的是用一台机器来搭建环境</p>
<ul>
<li>2 network interfaces // 需要一个网卡绑定IP，另一个不绑定IP</li>
<li>8GB main memory</li>
<li>40GB disk space</li>
<li>2 IP address // 其中一个先不绑定到网卡上，预留出来就好</li>
</ul>
<h1 id="安装依赖">安装依赖</h1>
<blockquote>
<p>[!tip]<br>
本次使用的是ubuntu 20.04操作系统，其他系统请使用相应的包管理器进行依赖安装</p>
</blockquote>
<pre><code class="language-shell">sudo apt update
sudo apt install git python3-dev libffi-dev gcc libssl-dev
</code></pre>
<h2 id="使用虚拟环境">使用虚拟环境</h2>
<blockquote>
<p>[!tip]<br>
官方推荐使用虚拟环境进行操作，避免依赖包和系统依赖包冲突<br>
不使用虚拟环境可跳过此步骤</p>
</blockquote>
<ol>
<li>安装虚拟环境</li>
</ol>
<pre><code class="language-shell">sudo apt install python3-venv
</code></pre>
<ol start="2">
<li>创建并激活虚拟环境</li>
</ol>
<pre><code class="language-shell">python3 -m venv /path/to/venv
source /path/to/venv/bin/activate
</code></pre>
<ol start="3">
<li>更新 pip</li>
</ol>
<pre><code class="language-shell">pip install -U pip
</code></pre>
<ol start="4">
<li>安装 ansible</li>
</ol>
<pre><code class="language-shell">pip install 'ansible&gt;=4,&lt;6'
</code></pre>
<h1 id="安装-kolla-ansible">安装 kolla-ansible</h1>
<blockquote>
<p>[!tip]<br>
如果未使用虚拟环境，请替换命令中的path</p>
</blockquote>
<ol>
<li>install kolla-ansible</li>
</ol>
<pre><code class="language-shell">pip install git+https://opendev.org/openstack/kolla-ansible@master
</code></pre>
<blockquote>
<p>[!warning]<br>
koll-ansible 15.0.0 不支持 Rocky linux 8 , 必须是Rocky linux 9<br>
如果是使用Rocky linux 8 , 可以通过下列命令安装低版本的 kolla-ansible。</p>
<pre><code class="language-shell">pip install kolla-ansible==14.7.0
</code></pre>
</blockquote>
<ol start="2">
<li>创建 <code>/etc/kolla</code> 目录</li>
</ol>
<pre><code class="language-shell">sudo mkdir -p /etc/kolla
sudo chown $USER:$USER /etc/kolla
</code></pre>
<ol start="3">
<li>复制配置文件到 <code>/etc/kolla</code> 目录</li>
</ol>
<pre><code class="language-shell">cp -r /path/to/venv/share/kolla-ansible/etc_examples/kolla/* /etc/kolla
</code></pre>
<ol start="4">
<li>复制 <code>all-in-one</code> inventory 文件到操作目录</li>
</ol>
<pre><code class="language-shell">cp /path/to/venv/share/kolla-ansible/ansible/inventory/all-in-one .
</code></pre>
<blockquote>
<p>[!note]<br>
操作目录可以随便指定<br>
all-in-one 默认是配置的loaclhost。会在当前机器搭建环境。 如果想在其他机器搭建环境，需要修改 <code>all-in-one</code> 中的hosts为服务器 ip，如果root禁止ssh登陆，需要指定 username</p>
</blockquote>
<h1 id="安装-anisble-galaxy-依赖">安装 Anisble Galaxy 依赖</h1>
<pre><code class="language-shell">kolla-ansible install-deps
</code></pre>
<h1 id="准备初始化配置">准备初始化配置</h1>
<h2 id="生成-kolla-password">生成 kolla password</h2>
<pre><code class="language-shell">kolla-genpwd
</code></pre>
<h2 id="修改-gloableyml-配置文件">修改 <code>gloable.yml</code> 配置文件</h2>
<ol>
<li>默认镜像</li>
</ol>
<pre><code class="language-shell">kolla_base_distro: &quot;rocky&quot;
</code></pre>
<blockquote>
<p>[!tip]<br>
可选值如下</p>
<ul>
<li>CentOS Stream (<code>centos</code>)</li>
<li>Debian (<code>debian</code>)</li>
<li>Rocky (<code>rocky</code>)</li>
<li>Ubuntu (<code>ubuntu</code>)</li>
</ul>
</blockquote>
<ol start="2">
<li>网络</li>
</ol>
<pre><code class="language-shell">network_interface: &quot;eth0&quot;
neutron_external_interface: &quot;eth1&quot;
kolla_internal_vip_address: &quot;10.1.0.250&quot;
</code></pre>
<blockquote>
<p>[!tip]<br>
<code>network_interface</code> - 需要填写绑定了IP地址的网卡的网口名字<br>
<code>neutron_external_interface</code> - 需要填写未绑定IP地址的网卡的网口名字<br>
<code>kolla_internal_vip_address</code> - 需要填写提前预留的 IP地址，不能是服务器绑定的IP</p>
</blockquote>
<ol start="3">
<li>启用服务<br>
因为是极简安装，全部使用默认的配置</li>
</ol>
<h1 id="部署openstack">部署openstack</h1>
<ol>
<li>部署 bootstrap-server和kolla依赖</li>
</ol>
<pre><code class="language-shell">kolla-ansible -i ./all-in-one bootstrap-servers
</code></pre>
<ol start="2">
<li>校验</li>
</ol>
<pre><code class="language-shell">kolla-ansible -i ./all-in-one prechecks
</code></pre>
<ol start="3">
<li>部署openstack</li>
</ol>
<pre><code class="language-shell">kolla-ansible -i ./all-in-one deploy
</code></pre>
<h1 id="使用-openstack">使用 openstack</h1>
<ol>
<li>安装 openstack CLI</li>
</ol>
<pre><code class="language-shell">pip install python-openstackclient -c https://releases.openstack.org/constraints/upper/master
</code></pre>
<ol start="2">
<li>生成 admin配置文件</li>
</ol>
<pre><code class="language-shell">kolla-ansible post-deploy
</code></pre>
<blockquote>
<p>[!tip]<br>
文件会生成在 <code>/etc/kolla/admin-openrc.sh</code> 这个脚本中有admin的帐号和密码。</p>
</blockquote>
<ol start="3">
<li>访问 openstack dashbord， <code>http://kolla_internal_vip_address/</code></li>
</ol>
<p>搞定！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[k8s打怪升级之路---第二关,安装监控组件---metrics-server]]></title>
        <id>https://alexritian.github.io/post/k8s-da-guai-sheng-ji-zhi-lu-di-er-guan-an-zhuang-jian-kong-zu-jian-metrics-server/</id>
        <link href="https://alexritian.github.io/post/k8s-da-guai-sheng-ji-zhi-lu-di-er-guan-an-zhuang-jian-kong-zu-jian-metrics-server/">
        </link>
        <updated>2023-01-28T08:33:34.000Z</updated>
        <summary type="html"><![CDATA[<p>简单的集群搭建起来了，通过k9s可以方便的访问和管理集群了，但是k9s上的cpu和memory数据总是N/A。<br>
给集群安装<code>metrics-server</code>让k9s可以读取到集群的资源使用情况。</p>
]]></summary>
        <content type="html"><![CDATA[<p>简单的集群搭建起来了，通过k9s可以方便的访问和管理集群了，但是k9s上的cpu和memory数据总是N/A。<br>
给集群安装<code>metrics-server</code>让k9s可以读取到集群的资源使用情况。</p>
<!-- more -->
<h1 id="安装">安装</h1>
<p>通过helm安装metrics-server</p>
<h2 id="下载chart文件">下载chart文件</h2>
<pre><code class="language-shell">helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/
helm pull metrics-server/metrics-server --version 3.8.2
</code></pre>
<blockquote>
<p>[!tip]<br>
网络好的可以不需要pull chat文件，直接执行install命令即可，install命令最后的 <code>.</code> 替换为 <code>metrics-server/metrics-server</code></p>
</blockquote>
<h2 id="install-chart">install chart</h2>
<p>解压chart文件，然后进入解压后的目录，执行下列命令</p>
<pre><code class="language-shell">helm install metrics-server .
</code></pre>
<p>安装完成之后，我们进入<code>k9s</code> 的界面就能够看到CPU，MEM的使用率了。</p>
<figure data-type="image" tabindex="1"><img src="https://alexritian.github.io/post-images/1674894990011.png" alt="" loading="lazy"></figure>
<h1 id="配置集群-context名字可选">配置集群 Context名字（可选）</h1>
<p>因为我的<strong>k9s</strong>是安装在部署服务器(非k8s集群服务器)，我将多个k8s集群的<code>config</code> 文件都拷贝到部署服务器方便使用<strong>k9s</strong>进行操作。<br>
在切换不同的集群的时候，发现<strong>k9s</strong>中显示的Context,Cluster,User都是一样的，有时候会分不清具体是在操作哪个集群。<br>
搜索了一下发现，<code>Context</code> 的值比较容易修改，不需要对集群进行改动。</p>
<p>执行命令修改当前 <code>config</code> 文件中的 <strong>context</strong> 的值</p>
<pre><code class="language-shell">kubectl config rename-context old-name new-name
</code></pre>
<p>修该完成之后再次进入 <strong>k9s</strong></p>
<figure data-type="image" tabindex="2"><img src="https://alexritian.github.io/post-images/1674895028148.png" alt="" loading="lazy"></figure>
<p>可以看到 <strong>Context</strong> 的值已经变为我们定义的名字，这样就方便的知道当前正在操作的是哪个集群了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[chrome添加私有CA证书(ubuntu版）]]></title>
        <id>https://alexritian.github.io/post/chrome-tian-jia-si-you-ca-zheng-shu-ubuntu-ban/</id>
        <link href="https://alexritian.github.io/post/chrome-tian-jia-si-you-ca-zheng-shu-ubuntu-ban/">
        </link>
        <updated>2023-01-28T08:00:59.000Z</updated>
        <summary type="html"><![CDATA[<p>ubuntu系统中chrome浏览器添加私有CA证书</p>
]]></summary>
        <content type="html"><![CDATA[<p>ubuntu系统中chrome浏览器添加私有CA证书</p>
<!-- more -->
<p>在ubuntu上通过chrome访问公司内网服务器，总是提示证书不授信。将CA证书添加到授信列表后，还是提示不授信。<br>
尝试通过 <code>curl -vvl</code> 访问域名，可以看到 <code>SSL certificate verify ok.</code><br>
此时需手动将CA证书添加到chrome证书管理中</p>
<ul>
<li>打开chrome settings -&gt; Privacy and Security -&gt; Security -&gt; Manage certificates</li>
<li>点击 <code>Authorities</code> 标签页</li>
<li>点击 <code>import</code> 按钮，然后选择CA证书。</li>
</ul>
<p>再次访问网站，就不会提示证书不授信了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[部署Chatwoot到kubernetes]]></title>
        <id>https://alexritian.github.io/post/bu-shu-chatwoot-dao-kubernetes/</id>
        <link href="https://alexritian.github.io/post/bu-shu-chatwoot-dao-kubernetes/">
        </link>
        <updated>2023-01-03T06:55:46.000Z</updated>
        <summary type="html"><![CDATA[<p>Chatwoot是一款开源在线聊天工具，记录一下如何部署chatwoot到kubernetes</p>
]]></summary>
        <content type="html"><![CDATA[<p>Chatwoot是一款开源在线聊天工具，记录一下如何部署chatwoot到kubernetes</p>
<!-- more -->
<p><a href="https://www.chatwoot.com/">chatwoot</a> 开源在线聊天工具（open source live chat)<br>
部署chatwoot到k8s集群，记录一下部署过程。</p>
<h1 id="deploy">deploy</h1>
<h2 id="perpare">perpare</h2>
<h3 id="创建命令空间可选">创建命令空间（可选）</h3>
<pre><code class="language-shell">kubectl create namespace chatwoot
</code></pre>
<h3 id="创建storeageclass">创建StoreageClass</h3>
<blockquote>
<p>[!tip]<br>
chatwoot 需要使用redis和pgsql，如果已经有redis和pgsql环境或者实例可以直接跳到 [[#deploy to k8s]]</p>
</blockquote>
<p>chatwoot-pgsql-storageclass.yaml</p>
<pre><code class="language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
    name: chatwoot-pgsql-storageclass
provisioner: kubernetes.io/no-provisioner
reclaimPolicy: Retain
</code></pre>
<p>chatwoot-redis-storageclass</p>
<pre><code class="language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
    name: chatwoot-redis-storageclass
provisioner: kubernetes.io/no-provisioner
reclaimPolicy: Retain
</code></pre>
<blockquote>
<p>[!note]<br>
因为我使用的是nfs，集群没有内置的nfs provisioner。我这里就设置为no-provisioner</p>
</blockquote>
<h3 id="创建pv">创建PV</h3>
<p>chatwoot需要使用3个PV，默认大小为8G。</p>
<p>chatwoot-pgsql-pv.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: chatwoot-postgres-pv
spec:
  capacity:
      storage: 8Gi
  accessModes:
      - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: &quot;chatwoot-pgsql-storageclass&quot;
  nfs:
    path: &lt;nfs path&gt;
    server: &lt;nfs server ip&gt;
</code></pre>
<p>chatwoot-redis-pv.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: chatwoot-redis-pv
spec:
  capacity:
      storage: 8Gi
  accessModes:
      - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: &quot;chatwoot-redis-storageclass&quot;
  nfs:
   path: &lt;nfs path&gt;
   server: &lt;nfs server ip&gt;
</code></pre>
<p>chatwoot-radis-pv.yaml</p>
<pre><code class="language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: chatwoot-rails-pv
spec:
  capacity:
      storage: 8Gi
  accessModes:
      - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: &quot;chatwoot-redis-storageclass&quot;
  nfs:
    path: &lt;nfs path&gt;
    server: &lt;nfs server ip&gt;
</code></pre>
<h2 id="deploy-to-k8s">deploy to k8s</h2>
<ul>
<li>添加helm repo</li>
</ul>
<pre><code class="language-shell">helm repo add chatwoot https://chatwoot.github.io/charts
</code></pre>
<ul>
<li>拉取chart文件</li>
</ul>
<pre><code class="language-shell">helm pull chatwoot/chatwoot
</code></pre>
<ul>
<li>
<p>解压缩</p>
</li>
<li>
<p>编辑charts/postgresql/values.yaml文件,修改 global.storageClass的值为准备阶段创建的storageClass的名字</p>
</li>
</ul>
<pre><code class="language-yaml">## @section Global parameters
## Please, note that this will override the parameters, including dependencies, configured to use the global value
##
global:
## @param global.storageClass Global StorageClass for Persistent Volume(s)
##
storageClass: &quot;chatwoot-pgsql-storageclass&quot;
</code></pre>
<ul>
<li>编辑charts/redis/values.yaml文件，修改 global.storageClass的值为准备阶段创建的storageClass的名字</li>
</ul>
<pre><code class="language-yaml">## @section Global parameters
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass
##

## @param global.imageRegistry Global Docker image registry
## @param global.imagePullSecrets Global Docker registry secret names as an array
## @param global.storageClass Global StorageClass for Persistent Volume(s)
## @param global.redis.password Global Redis&amp;reg; password (overrides `auth.password`)
##
global:
storageClass: &quot;chatwoot-pgsql-storageclass&quot;
</code></pre>
<blockquote>
<p>[!tip]<br>
可以动态为chatwoot制备PV，<s>这个我还不会</s></p>
</blockquote>
<ul>
<li>开启帐号注册(可选)</li>
</ul>
<p>编辑chart文件根目录下的values.yaml文件，也可以通过在安装命令中增加参数来配置。</p>
<pre><code class="language-yaml">env:
ENABLE_ACCOUNT_SIGNUP: true
</code></pre>
<blockquote>
<p>[!tip]<br>
这里还有一个值 <strong>FRONTEND_URL</strong> ， 这个是配置chatwoot的url，默认值为 http://0.0.0.0:3000.<br>
这个url会在集成chatwoot的时候使用，配置了之后 chatwoot自动生成的代码就不需要修改了。如果不配置，需要将自动生成的代码中的 http://0.0.0.0:3000 替换为集群的IP和chatwoot暴露出来的端口号。</p>
<p>下面是配置SMTP的，如果需要邮件服务需要配置SMTP。 注册帐号需要邮箱认证，不配置SMTP无法发送认证邮件。<br>
SMTP_ADDRESS: &quot;&quot;</p>
<p>SMTP_AUTHENTICATION: plain</p>
<p>SMTP_ENABLE_STARTTLS_AUTO: true</p>
<p>SMTP_OPENSSL_VERIFY_MODE: none</p>
<p>SMTP_PASSWORD: &quot;&quot;</p>
<p>SMTP_PORT: 587</p>
<p>SMTP_USERNAME: &quot;&quot;</p>
</blockquote>
<ul>
<li>install chart</li>
</ul>
<pre><code class="language-shell">helm install chatwoot . -n chatwoot 
</code></pre>
<h1 id="config">config</h1>
<h2 id="创建超级管理员帐号">创建超级管理员帐号</h2>
<p>需要进入 chatwoot-web pod执行下列命令， 密码必须包含大写字母，小写字母，数字和特殊字符</p>
<pre><code class="language-shell">// 进入 rails
RAILS_ENV=production bundle exec rails c

// 创建管理员帐号
SuperAdmin.create!(email: &quot;&lt;email address&gt;&quot;, password: &quot;&lt;password&gt;&quot; , name: &quot;&lt;name&gt;&quot; )

admin = User.where(email: '&lt;email address&gt;', type: 'SuperAdmin').first
// 邮箱确认
admin.confirm
// 保存
admin.save
</code></pre>
<blockquote>
<p>[!tip]<br>
超级管理员地址： http://ip:port/super_admin</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java12-Java17新特性]]></title>
        <id>https://alexritian.github.io/post/java12-java17-xin-te-xing/</id>
        <link href="https://alexritian.github.io/post/java12-java17-xin-te-xing/">
        </link>
        <updated>2022-11-08T01:26:36.000Z</updated>
        <summary type="html"><![CDATA[<p>从网上收集整理Java12-Java17的非预览，非孵化的特性</p>
]]></summary>
        <content type="html"><![CDATA[<p>从网上收集整理Java12-Java17的非预览，非孵化的特性</p>
<!-- more -->
<h1 id="参考文章">参考文章</h1>
<ol>
<li><a href="https://jdk.java.net/archive/">OpenJDK Java 17 下载</a></li>
<li><a href="https://openjdk.java.net/projects/jdk/17/">OpenJDK Java 17 文档</a></li>
<li><a href="https://www.wdbyte.com/java/java-17/">https://www.wdbyte.com/java/java-17/</a></li>
<li>https://docs.oracle.com/en/java/javase/17/</li>
</ol>
<h1 id="编码相关非预览">编码相关(非预览)</h1>
<h2 id="文件对比-filesmismatch">文件对比 Files.mismatch</h2>
<p>对比两个文件，如果内容一致，会返回 -1 ，如果内容不同，会返回不同的字节开始位置。</p>
<pre><code class="language-java">// 创建两个文件
Path pathA = Files.createFile(Paths.get(&quot;a.txt&quot;));
Path pathB = Files.createFile(Paths.get(&quot;b.txt&quot;));

// 写入相同内容
Files.write(pathA,&quot;abc&quot;.getBytes(), StandardOpenOption.WRITE);
Files.write(pathB,&quot;abc&quot;.getBytes(), StandardOpenOption.WRITE);
long mismatch = Files.mismatch(pathA, pathB);
System.out.println(mismatch);

// 追加不同内容
Files.write(pathA,&quot;123&quot;.getBytes(), StandardOpenOption.APPEND);
Files.write(pathB,&quot;321&quot;.getBytes(), StandardOpenOption.APPEND);
mismatch = Files.mismatch(pathA, pathB);
System.out.println(mismatch);

// 删除创建的文件
pathA.toFile().deleteOnExit();
pathB.toFile().deleteOnExit();

// RESULT
// -1
// 3
</code></pre>
<h2 id="compact-number">Compact Number</h2>
<p>简化的数字格式可以直接转换数字显示格式，比如 1000 -&gt; 1K，1000000 -&gt; 1M 。</p>
<pre><code class="language-java">System.out.println(&quot;Compact Formatting is:&quot;);
NumberFormat upvotes = NumberFormat.getCompactNumberInstance(new Locale(&quot;en&quot;, &quot;US&quot;), Style.SHORT);

System.out.println(upvotes.format(100));
System.out.println(upvotes.format(1000));
System.out.println(upvotes.format(10000));
System.out.println(upvotes.format(100000));
System.out.println(upvotes.format(1000000));

// 设置小数位数
upvotes.setMaximumFractionDigits(1);
System.out.println(upvotes.format(1234));
System.out.println(upvotes.format(123456));
System.out.println(upvotes.format(12345678));
</code></pre>
<p>输出：</p>
<pre><code>100
1K
10K
100K
1M
1.2K
123.5K
12.3M
</code></pre>
<h2 id="jep-353重新实现socket-api">JEP 353：重新实现Socket API</h2>
<p><code>java.net.Socket</code> 和 <code>java.net.ServerSocket</code> 类早在 Java 1.0 时就已经引入了，它们的实现的 Java 代码和 C 语言代码的混合，维护和调试都十分不易；而且这个实现还存在并发问题，有时候排查起来也很困难。</p>
<p>因此，在 Java 13 中引入了新的实现方式，使用了新的实现 <code>NioSocketImpl</code> 来代替老旧的 <code>PlainSocketImpl</code> 实现。虽然功能相同，但是老的方式在当前以及未来几个版本内不会删除，用户随时可以通过 <code>-Djdk.net.usePlainSocketImpl</code> 参数切换回老的实现方式，以兼容意外情况。</p>
<pre><code class="language-java">import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
public class Test {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(8000)){
            boolean running = true;
            while(running){
                Socket clientSocket = serverSocket.accept();
                //do something with clientSocket
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<p>使用 Java 13 运行，通过参数 <code>-XX:+TraceClassLoading</code> 追踪加载的类，日志中可以看到 <code>NioSocketImpl</code>。</p>
<pre><code class="language-shell">➜  develop ./jdk-13.0.2.jdk/Contents/Home/bin/java -XX:+TraceClassLoading Test.java | grep SocketImpl
[0.699s][info   ][class,load] java.net.SocketImpl source: jrt:/java.base
[0.699s][info   ][class,load] java.net.SocketImpl$$Lambda$173/0x0000000800c37440 source: java.net.SocketImpl
[0.702s][info   ][class,load] sun.net.PlatformSocketImpl source: jrt:/java.base
[0.702s][info   ][class,load] sun.nio.ch.NioSocketImpl source: jrt:/java.base
[0.713s][info   ][class,load] sun.nio.ch.NioSocketImpl$FileDescriptorCloser source: jrt:/java.base
</code></pre>
<p>但在 Java 12 并不是 <code>NioSocketImpl</code>。</p>
<pre><code class="language-shell">➜  develop ./jdk-12.0.2.jdk/Contents/Home/bin/java -XX:+TraceClassLoading Test.java | grep SocketImpl
[0.665s][info   ][class,load] java.net.SocketImpl source: jrt:/java.base
[0.665s][info   ][class,load] java.net.AbstractPlainSocketImpl source: jrt:/java.base
[0.665s][info   ][class,load] java.net.PlainSocketImpl source: jrt:/java.base
[0.665s][info   ][class,load] java.net.SocksSocketImpl source: jrt:/java.base
[0.666s][info   ][class,load] java.net.AbstractPlainSocketImpl$1 source: jrt:/java.base
</code></pre>
<h2 id="jep-358更有用的nullpointerexceptions">JEP 358：更有用的NullPointerExceptions</h2>
<p><code>NullPointerException</code> 一直都是一个比较常见的异常，但是在 Java 14 之前，如果一行有多个表达式时，这时报了空指针后，单纯的从报错信息来看，可能并不知道是哪个对象为 <code>NULL</code> ，下面是一个演示。</p>
<pre><code class="language-java">package com.wdbyte;

public class Java14NullPointerExceptions {

    public static void main(String[] args) {
        String content1 = &quot;www.wdbyte.com&quot;;
        String content2 = null;
        int length = content1.length() + content2.length();
        System.out.println(length);
    }
}
</code></pre>
<p>在 Java 14 之前，从下面的报错中我们只能得到错误出现的行数，但是并不能确定是 <code>conteng1</code> 还是 <code>content2</code> 为 <code>null</code>。</p>
<pre><code class="language-shell">Exception in thread &quot;main&quot; java.lang.NullPointerException
	at com.alibaba.security.astralnet.console.controller.ApiChartsTest.main(Java14NullPointerExceptions.java:8)
</code></pre>
<p>但是在 Java 14 中，会清晰的告诉你 <code>because &quot;content2&quot; is null</code> 。</p>
<pre><code class="language-shell">Exception in thread &quot;main&quot; java.lang.NullPointerException: 
	Cannot invoke &quot;String.length()&quot; because &quot;content2&quot; is null
	at com.wdbyte.Java14NullPointerExceptions.main(Java14NullPointerExceptions.java:8)
</code></pre>
<h2 id="jep-361-swtich表达式标准">JEP 361: Swtich表达式（标准）</h2>
<p>Switch 表达式改进从 Java 12 就已经开始了，[[Java 12 新功能#Switch 表达式（JEP 325 （预览）|Java 12 让 switch 支持了 <code>L-&gt;</code> 语法]]，[[Java 13 新功能#Switch表达式 二次预览 （JEP 354|Java 13 引入了 <code>yield</code> 关键词用于返回结果]]，但是在 Java 12 和 13 中功能都是预览版的，而在 Java 14 中，正式转正。</p>
<pre><code class="language-java">// 通过传入月份，输出月份所属的季节
public static String switchJava12(String month) {
     return switch (month) {
        case &quot;march&quot;, &quot;april&quot;, &quot;may&quot;            -&gt; &quot;春天&quot;;
        case &quot;june&quot;, &quot;july&quot;, &quot;august&quot;           -&gt; &quot;夏天&quot;;
        case &quot;september&quot;, &quot;october&quot;, &quot;november&quot; -&gt; &quot;秋天&quot;;
        case &quot;december&quot;, &quot;january&quot;, &quot;february&quot;  -&gt; &quot;冬天&quot;;
        default -&gt; &quot;month erro&quot;;
    };
}
// 通过传入月份，输出月份所属的季节
public static String switchJava13(String month) {
    return switch (month) {
        case &quot;march&quot;, &quot;april&quot;, &quot;may&quot;:
            yield &quot;春天&quot;;
        case &quot;june&quot;, &quot;july&quot;, &quot;august&quot;:
            yield &quot;夏天&quot;;
        case &quot;september&quot;, &quot;october&quot;, &quot;november&quot;:
            yield &quot;秋天&quot;;
        case &quot;december&quot;, &quot;january&quot;, &quot;february&quot;:
            yield &quot;冬天&quot;;
        default:
            yield &quot;month error&quot;;
    };
}
</code></pre>
<h2 id="jep-339爱德华曲线算法eddsa">JEP 339：爱德华曲线算法(EdDSA)</h2>
<p>Java 15 中增加了一个新的密码学算法，爱德华曲线算法（EdDSA）签名算法。它是由 Schnorr 算法发展而来，在 RFC8032 中被定义实现。</p>
<pre><code class="language-java">package com.wdbyte;

import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.Signature;
import java.security.SignatureException;
import java.util.Base64;

public class JEP339 {

    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException {
        KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;);
        KeyPair kp = kpg.generateKeyPair();
        byte[] msg = &quot;www.wdbyte.com&quot;.getBytes(StandardCharsets.UTF_8);
        Signature sig = Signature.getInstance(&quot;Ed25519&quot;);
        sig.initSign(kp.getPrivate());
        sig.update(msg);
        byte[] s = sig.sign();
        System.out.println(Base64.getEncoder().encodeToString(s));
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>VXlpxapU+LSWjVQ0QNJvdpUh6VI6PjSwOQ2pHu65bCfnLR13OyWKunlc9rc+7SMxCh2Mnqf7TmC/iOG8oimbAw==
</code></pre>
<h2 id="jep-371hidden-classes隐藏类">JEP 371：Hidden Classes(隐藏类)</h2>
<p>这个特性让开发者可以引入一个无法被其他地方发现使用，且类的生命周期有限的类。这对运行时动态生成类的使用方式十分有利，可以减少内存占用，下面是一个使用示例。</p>
<pre><code class="language-java">package com.wdbyte;

public class JEP371Test {
    public static String lookup() {
      return &quot;www.wdbyte.com&quot;;
    }
}
</code></pre>
<p>把类 <code>JEP371Test</code> 编译后的 Class 转换成 <code>Base64</code>，然后使用 Java 15 新特性加载调用类中的 <code>lookup</code> 方法。</p>
<pre><code class="language-java">package com.wdbyte;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.util.Base64;

/**
 * @author www.wdbyte.com
 */
public class JEP371 {

    private static String CLASS_INFO = &quot;yv66vgAAADQAFAoAAgADBwAEDAAFAAYBABBqYXZhL2xhbmcvT2JqZWN0AQAGPGluaXQ+AQADKClWCAAIAQAOd3d3LndkYnl0ZS5jb20HAAoBABVjb20vd2RieXRlL0pFUDM3MVRlc3QBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAF0xjb20vd2RieXRlL0pFUDM3MVRlc3Q7AQAGbG9va3VwAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAApTb3VyY2VGaWxlAQAPSkVQMzcxVGVzdC5qYXZhACEACQACAAAAAAACAAEABQAGAAEACwAAAC8AAQABAAAABSq3AAGxAAAAAgAMAAAABgABAAAAAwANAAAADAABAAAABQAOAA8AAAAJABAAEQABAAsAAAAbAAEAAAAAAAMSB7AAAAABAAwAAAAGAAEAAAAEAAEAEgAAAAIAEw==&quot;;

    public static void main(String[] args) throws Throwable {
        byte[] classInBytes = Base64.getDecoder().decode(CLASS_INFO);
        Class&lt;?&gt; proxy = MethodHandles.lookup()
            .defineHiddenClass(classInBytes, true, MethodHandles.Lookup.ClassOption.NESTMATE)
            .lookupClass();

        System.out.println(proxy.getName());
        MethodHandle mh = MethodHandles.lookup().findStatic(proxy, &quot;lookup&quot;, MethodType.methodType(String.class));
        String result = (String) mh.invokeExact();
        System.out.println(result);
    }
}
</code></pre>
<p>输出结果</p>
<pre><code>com.wdbyte.JEP371Test/0x0000000800c01800
www.wdbyte.com
</code></pre>
<h2 id="jep-378文本块">JEP 378文本块</h2>
<p>在这之前，如果我们把一个 JSON 赋值给字符串：</p>
<pre><code class="language-java">String content = &quot;{\n&quot;
    + &quot;    \&quot;upperSummary\&quot;: null,\n&quot;
    + &quot;    \&quot;sensitiveTypeList\&quot;: null,\n&quot;
    + &quot;    \&quot;gmtModified\&quot;: \&quot;2011-08-05 10:50:09\&quot;,\n&quot;
    + &quot;    \&quot;lowerGraph\&quot;: null,\n&quot;
    + &quot;    \&quot;signature\&quot;: \&quot;\&quot;,\n&quot;
    + &quot;    \&quot;appName\&quot;: \&quot;xxx\&quot;,\n&quot;
    + &quot;    \&quot;lowerSummary\&quot;: null,\n&quot;
    + &quot;    \&quot;gmtCreate\&quot;: \&quot;2011-08-05 10:50:09\&quot;,\n&quot;
    + &quot;    \&quot;type\&quot;: \&quot;CALL\&quot;,\n&quot;
    + &quot;    \&quot;name\&quot;: \&quot;xxxx\&quot;,\n&quot;
    + &quot;    \&quot;subType\&quot;: \&quot;yyy\&quot;,\n&quot;
    + &quot;    \&quot;id\&quot;: 1,\n&quot;
    + &quot;    \&quot;projectId\&quot;: 1,\n&quot;
    + &quot;    \&quot;status\&quot;: 1\n&quot;
    + &quot;}&quot;;
</code></pre>
<p>终于不用写丑陋的长字符串了，你可以使用文本块的方式定义字符串了。</p>
<pre><code class="language-java">String content2 = &quot;&quot;&quot;
        {
        &quot;upperSummary&quot;: null,
        &quot;sensitiveTypeList&quot;: null,
        &quot;gmtModified&quot;: &quot;2011-08-05 10:50:09&quot;,
        &quot;lowerGraph&quot;: null,
        &quot;signature&quot;: &quot;&quot;,
        &quot;appName&quot;: &quot;xxx&quot;,
        &quot;lowerSummary&quot;: null,
        &quot;gmtCreate&quot;: &quot;2011-08-05 10:50:09&quot;,
        &quot;type&quot;: &quot;CALL&quot;,
        &quot;name&quot;: &quot;xxxx&quot;,
        &quot;subType&quot;: &quot;yyy&quot;,
        &quot;id&quot;: 1,
        &quot;projectId&quot;: 1,
        &quot;status&quot;: 1
    }
                 &quot;&quot;&quot;;
</code></pre>
<p>两个特殊的转义符</p>
<ol>
<li><code>\</code> 结尾不换行</li>
<li><code>\s</code> 表示一个空格</li>
</ol>
<p>示例：文本块体验</p>
<pre><code class="language-java">String content = &quot;&quot;&quot;
        {
            &quot;upperSummary&quot;: null,\
            &quot;sensitiveTypeList&quot;: null,
            &quot;gmtModified&quot;: &quot;2011-08-05\s10:50:09&quot;,
        }
         &quot;&quot;&quot;;
System.out.println(content);
</code></pre>
<p>输出结果：</p>
<pre><code class="language-json">{
    &quot;upperSummary&quot;: null,    &quot;sensitiveTypeList&quot;: null,
    &quot;gmtModified&quot;: &quot;2011-08-05 10:50:09&quot;,
}
</code></pre>
<h2 id="jep-390基于值的类的警告">JEP 390：基于值的类的警告</h2>
<p>添加了一个注解，用于标识当前是是基于值的类，比如 Java 8 引入的预防空指针的 Optional 类，现在已经添加了注解标识。</p>
<pre><code class="language-java">@jdk.internal.ValueBased
public final class Optional&lt;T&gt; {
    // ...
}
</code></pre>
<h2 id="jep-394instanceof-模式匹配">JEP 394：instanceof 模式匹配</h2>
<p>在之前，使用 <code>instanceof</code> 需要如下操作：</p>
<pre><code class="language-java">if (obj instanceof String) {
    String s = (String) obj;    // grr...
    ...
}
</code></pre>
<p>多余的类型强制转换，而现在：</p>
<pre><code class="language-java">if (obj instanceof String s) {
    // Let pattern matching do the work!
    ...
}
</code></pre>
<h2 id="jep-395records">JEP 395：Records</h2>
<p><code>record</code> 是一种全新的类型，它本质上是一个 <code>final</code> 类，同时所有的属性都是 <code>final</code> 修饰，它会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法，减少了代码编写量。</p>
<p>示例：编写一个 Dog record 类，定义 name 和 age 属性。</p>
<pre><code class="language-java">package com.wdbyte;

public record Dog(String name, Integer age) {
}
</code></pre>
<p>Record 的使用。</p>
<pre><code class="language-java">package com.wdbyte;

public class Java14Record {

    public static void main(String[] args) {
        Dog dog1 = new Dog(&quot;牧羊犬&quot;, 1);
        Dog dog2 = new Dog(&quot;田园犬&quot;, 2);
        Dog dog3 = new Dog(&quot;哈士奇&quot;, 3);
        System.out.println(dog1);
        System.out.println(dog2);
        System.out.println(dog3);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-shell">Dog[name=牧羊犬, age=1]
Dog[name=田园犬, age=2]
Dog[name=哈士奇, age=3]
</code></pre>
<h2 id="jep-306-恢复始终严格的浮点语义">JEP 306： 恢复始终严格的浮点语义</h2>
<p>既然是恢复严格的浮点语义，那么说明在某个时间点之前，是始终严格的浮点语义的。其实在 Java SE 1.2 之前，所有的浮点计算都是严格的，但是以当初的情况来看，过于严格的浮点计算在当初流行的 x86 架构和 x87 浮点协议处理器上运行，需要大量的额外的指令开销，所以在 Java SE 1.2 开始，需要手动使用关键字 <strong>strictfp</strong>（strict float point） 才能启用严格的浮点计算。</p>
<p>但是在 2021 年的今天，硬件早已发生巨变，当初的问题已经不存在了，所以从 Java 17 开始，恢复了始终严格的浮点语义这一特性。</p>
<p><strong>扩展</strong>：<em><strong>strictfp</strong></em> 是 Java 中的一个关键字，大多数人可能没有注意过它，它可以用在类、接口或者方法上，被 strictfp 修饰的部分中的 float 和 double 表达式会进行严格浮点计算。</p>
<p>下面是一个示例，其中的 <code>testStrictfp()</code> 被 <code>strictfp</code> 修饰。</p>
<pre><code class="language-java">package com.wdbyte;

public class Main {
    public static void main(String[] args) {
        testStrictfp();
    }

    public strictfp static void testStrictfp() {
        float aFloat = 0.6666666666666666666f;
        double aDouble = 0.88888888888888888d;
        double sum = aFloat + aDouble;
        System.out.println(&quot;sum: &quot; + sum);
    }
}
</code></pre>
<h2 id="jep-356增强的伪随机数生成器">JEP 356：增强的伪随机数生成器</h2>
<p>为伪随机数生成器 RPNG（pseudorandom number generator）增加了新的接口类型和实现，让在代码中使用各种 PRNG 算法变得容易许多。</p>
<p>这次增加了 <code>RandomGenerator</code> 接口，为所有的 PRNG 算法提供统一的 API，并且可以获取不同类型的 PRNG 对象流。同时也提供了一个新类 <code>RandomGeneratorFactory</code> 用于构造各种 <code>RandomGenerator</code> 实例，在 <code>RandomGeneratorFactory</code> 中使用 <code>ServiceLoader.provider</code> 来加载各种 PRNG 实现。</p>
<p>下面是一个使用示例：随便选择一个 PRNG 算法生成 5 个 10 以内的随机数。</p>
<pre><code class="language-java">package com.wdbyte.java17;

import java.util.Date;
import java.util.random.RandomGenerator;
import java.util.random.RandomGeneratorFactory;
import java.util.stream.Stream;

/**
 * @author niulang
 */
public class JEP356 {

    public static void main(String[] args) {
        RandomGeneratorFactory&lt;RandomGenerator&gt; l128X256MixRandom = RandomGeneratorFactory.of(&quot;L128X256MixRandom&quot;);
        // 使用时间戳作为随机数种子
        RandomGenerator randomGenerator = l128X256MixRandom.create(System.currentTimeMillis());
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(randomGenerator.nextInt(10));
        }
    }
}

</code></pre>
<p>得到输出：</p>
<pre><code>7
3
4
4
6
</code></pre>
<p>你也可以遍历出所有的 PRNG 算法。</p>
<pre><code>RandomGeneratorFactory.all().forEach(factory -&gt; {
    System.out.println(factory.group() + &quot;:&quot; + factory.name());
});
</code></pre>
<p>得到输出：</p>
<pre><code>LXM:L32X64MixRandom
LXM:L128X128MixRandom
LXM:L64X128MixRandom
Legacy:SecureRandom
LXM:L128X1024MixRandom
LXM:L64X128StarStarRandom
Xoshiro:Xoshiro256PlusPlus
LXM:L64X256MixRandom
Legacy:Random
Xoroshiro:Xoroshiro128PlusPlus
LXM:L128X256MixRandom
Legacy:SplittableRandom
LXM:L64X1024MixRandom
</code></pre>
<p>可以看到 <code>Legacy:Random</code> 也在其中，新的 API 兼容了老的 <code>Random</code> 方式，所以你也可以使用新的 API 调用 <code>Random</code> 类生成随机数。</p>
<pre><code class="language-java">// 使用 Random
RandomGeneratorFactory&lt;RandomGenerator&gt; l128X256MixRandom = RandomGeneratorFactory.of(&quot;Random&quot;);
// 使用时间戳作为随机数种子
RandomGenerator randomGenerator = l128X256MixRandom.create(System.currentTimeMillis());
for (int i = 0; i &lt; 5; i++) {
    System.out.println(randomGenerator.nextInt(10));
}
</code></pre>
<h2 id="jep-409密封类sealed-classes">JEP 409：密封类（Sealed Classes）</h2>
<p>我们都知道，在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 <code>final</code> 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 <code>sealed</code> 类，被 <code>sealed</code> 修饰的类可以指定子类。这样这个类就只能被指定的类继承。</p>
<p>而且 <code>sealed</code> 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 <code>final</code>、<code>sealed</code>、<code>non-sealed</code> 三者之一。</p>
<p>示例：犬类（Dog）只能被牧羊犬（Collie）和田园犬（TuGou）继承，使用 <code>sealed</code> 关键字。</p>
<pre><code class="language-java">package com.wdbyte;

public  sealed interface Dog permits Collie, TuGou {
    //...
}
</code></pre>
<p>牧羊犬（Collie）只能被边境牧羊犬（BorderCollie）继承。</p>
<pre><code class="language-java">package com.wdbyte;

/**
 * 牧羊犬
 * @author www.wdbyte.com
 */
public sealed class Collie implements Dog permits BorderCollie {

}
</code></pre>
<p>边境牧羊犬（BorderCollie）不能被继承，使用 <code>final</code> 关键字。</p>
<pre><code class="language-java">package com.wdbyte;

/**
 *
 * @author www.wdbyte.com
 */
public final class BorderCollie extends Collie{
}
</code></pre>
<p>田园犬（ToGou）可以被任意继承，使用 <code>non-sealed</code> 关键字。</p>
<pre><code class="language-java">package com.wdbyte;

/**
 * @author niulang
 */
public non-sealed class TuGou implements Dog {
}
</code></pre>
<h2 id="jep-415指定上下文的反序列化过滤器">JEP 415：指定上下文的反序列化过滤器</h2>
<p>Java 中的序列化一直都是<br>
非常重要的功能，如果没有序列化功能，Java 可能都不会占据开发语言的主导地位，序列化让远程处理变得容易和透明，同时也促进了 Java EE 的成功。</p>
<p>但是 Java 序列化的问题也很多，它几乎会犯下所有的可以想象的错误，为开发者带来持续的维护工作。但是要说明的是序列化的概念是没有错的，把对象转换为可以在 JVM 之间自由传输，并且可以在另一端重新构建的能力是完全合理的想法，问题在于 Java 中的序列化设计存在风险，以至于爆出过很多和序列化相关的漏洞。</p>
<p>反序列化危险的一个原因是，有时候我们不好验证将要进行反序列化的内容是否存在风险，而传入的数据流可以自由引用对象，很有可能这个数据流就是攻击者精心构造的恶意代码。</p>
<p>所以，JEP 415 允许在反序列化时，通过一个过滤配置，来告知本次反序列化允许或者禁止操作的类，反序列化时碰到被禁止的类，则会反序列化失败。</p>
<h3 id="反序列化示例">反序列化示例</h3>
<p>假设 Dog 类中的 Poc 是恶意构造的类，但是正常反序列化是可以成功的。</p>
<pre><code class="language-java">package com.wdbyte.java17;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @author niulang
 */
public class JEP415 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Dog dog = new Dog(&quot;哈士奇&quot;);
        dog.setPoc(new Poc());
        // 序列化 - 对象转字节数组
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);) {
            objectOutputStream.writeObject(dog);
        }
        byte[] bytes = byteArrayOutputStream.toByteArray();
        // 反序列化 - 字节数组转对象
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        Object object = objectInputStream.readObject();
        System.out.println(object.toString());
    }
}

class Dog implements Serializable {
    private String name;
    private Poc poc;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Dog{&quot; + &quot;name='&quot; + name + '\'' + '}';
    }
		// get...set...
}

class Poc implements Serializable{

}
</code></pre>
<p>输出结果：</p>
<pre><code>Dog{name='哈士奇'}
</code></pre>
<h3 id="反序列化过滤器">反序列化过滤器</h3>
<p>在 Java 17 中可以自定义反序列化过滤器，拦截不允许的类。</p>
<pre><code class="language-java">package com.wdbyte.java17;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputFilter;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

/**
 * @author niulang
 */
public class JEP415 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Dog dog = new Dog(&quot;哈士奇&quot;);
        dog.setPoc(new Poc());
        // 序列化 - 对象转字节数组
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);) {
            objectOutputStream.writeObject(dog);
        }
        byte[] bytes = byteArrayOutputStream.toByteArray();
        // 反序列化 - 字节数组转对象
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        // 允许 com.wdbyte.java17.Dog 类，允许 java.base 中的所有类，拒绝其他任何类
        ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(
                        &quot;com.wdbyte.java17.Dog;java.base/*;!*&quot;);
        objectInputStream.setObjectInputFilter(filter);
        Object object = objectInputStream.readObject();
        System.out.println(object.toString());
    }
}

class Dog implements Serializable {
    private String name;
    private Poc poc;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Dog{&quot; + &quot;name='&quot; + name + '\'' + '}';
    }
		// get...set...
}

class Poc implements Serializable{
}
</code></pre>
<p>这时反序列化会得到异常。</p>
<pre><code class="language-java">Exception in thread &quot;main&quot; java.io.InvalidClassException: filter status: REJECTED
	at java.base/java.io.ObjectInputStream.filterCheck(ObjectInputStream.java:1412)
	at java.base/java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2053)
	at java.base/java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1907)
	....
</code></pre>
<h2 id="jep-373重新实现datagramsocket-api">JEP 373：重新实现DatagramSocket API</h2>
<h2 id="jep374禁用和废弃偏向锁biased-locking">JEP374：禁用和废弃偏向锁（Biased Locking)</h2>
<p>在之前，JVM 在处理同步操作，如使用 <code>synchronized</code> 同步时，有一套锁的升级机制，其中有一个锁机制就是偏向锁。然而通过目前的 Java 开发环境来看，使用这些被 <code>synchronized</code> 同步的类的机会并不多，如开发者更喜欢使用 <code>HashMap</code> 或者 <code>ArrayList</code> 而非 <code>HashTable</code> 和 <code>Vector</code>。</p>
<p>即使换个角度，当初使用偏向锁是为了提高性能，如今看来性能提升的程度和使用次数都不太有用。而偏向锁的引入增加了 JVM 的复杂性。</p>
<p>所以现在偏向锁被默认禁用，在不久的将来将会彻底删除</p>
<h2 id="jep-411弃用-security-manager">JEP 411：弃用 Security Manager</h2>
<p><strong>Security Manager</strong> 在 JDK 1.0 时就已经引入，但是它一直都不是保护服务端以及客户端 Java 代码的主要手段，为了 Java 的继续发展，决定弃用 Security Manager，在不久的未来进行删除。</p>
<pre><code class="language-java">@Deprecated(since=&quot;17&quot;, forRemoval=true)
public class SecurityManager {
	// ...
}
</code></pre>
<h1 id="其他">其他</h1>
<h2 id="jep-189-shenandoah垃圾收集器">JEP 189: Shenandoah垃圾收集器</h2>
<p>Java 12 增加了 Shenandoah 一个低停顿的垃圾收集器，它可以和 Java 应用程序中的执行线程同时进行，用来收集垃圾进行内容回收，这样就可以让停顿时间更少。</p>
<p>更多关于 Shenandoah 垃圾收集器的介绍可以查看文档：<a href="https://wiki.openjdk.java.net/display/shenandoah/Main#Main-Overview">Shenandoah GC 介绍</a>。</p>
<h2 id="zgc并发类卸载">ZGC并发类卸载</h2>
<p>Z 垃圾收集器现在支持类卸载，通过卸载不使用的类来释放这些类相关的数据结构，从而减少应用程序的总体占用空间。因为是并发执行，所以不会停止 Java 应用程序线程的执行，也因此对 GC 的暂停时间影响微乎其微。默认情况下启用此功能，但可以使用命令行选项禁用 <code>-XX:-ClassUnloading</code>。</p>
<h2 id="jep-334-jvm常量api">JEP 334: JVM常量API</h2>
<p>在包 <code>java.lang.invoke.constant</code> 中定义了一系列的基于值的符号引用，可以用来描述各种可加载常量。可以更容易的对关键类文件和运行时构建的名义描述进行建模，特别是对那些从常量池中加载的常量，也让开发者可以更简单标准的处理可加载常量。</p>
<h2 id="jep-314-默认使用类数据共享cds">JEP 314: 默认使用类数据共享(CDS)</h2>
<p>CDS 可以让 JVM 在同一台机器或虚拟机上启动多个应用的速度速度大大增加。原理是在启动应用时共享一些类加载信息，这样启动新进程时就可以使用共享的数据。在 Java 12 之前此功能需要手动开启，Java 12 调整为默认开启。</p>
<h2 id="jep-230-微基准套件">JEP 230: 微基准套件</h2>
<p>Java 12 中添加一套新的基于 JMH 的基本的微基准测试套件。</p>
<h2 id="jep-350动态cds存档">JEP 350：动态CDS存档</h2>
<p>JVM 启动时有一步是需要在内存中加载类，而如果有多个 jar，加载第一个 jar 的速度是最慢的。这就延长了程序的启动时间，为了减少这个时间，<code>Java 10</code> 引入了应用程序类数据共享（CDS）机制，它可以把你想共享的类共享在程序之间，使不同的 Java 进程之间共享这个类来减少这个类占用的空间以及加载速度。不过 Java 10 中使用这个功能的步骤比较繁琐。<br>
而 Java 13 中的 AppCDS，允许 Java 应用在程序执行结束时（如果 JVM 没有崩溃）进行动态存档；存储的内容包括所有加载的应用类型类和使用的类库，这些存储的类库本来并不存在于默认的 CDS 存档中。<br>
使用这个功能非常简单，只需要在程序启动时增加启动参数 。</p>
<pre><code class="language-shell"># ArchiveClassesAtExit，程序结束时动态存档
bin/java -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello
# SharedArchiveFile，使用指定存档启动
bin/java -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello
</code></pre>
<h2 id="jep-351zgc-归还未使用的内存实验性">JEP 351：ZGC 归还未使用的内存（实验性）</h2>
<p>在 Java 13 之前，ZGC 虽然在清理内存时导致的停顿时间非常少，但是即使内存已经长时间没有使用，ZGC 也不会将内存返还给操作系统，这对那些十分关注内存占用的应用程序非常不友好。<br>
比如：</p>
<ul>
<li>资源按使用量付费的云上容器环境。</li>
<li>应用虽然长时间闲置，但是占用了内存，导致运行的其他程序内存紧张。<br>
而新增的这个功能，可以让 ZGC 归还长时间没有使用的内存给操作系统，这对某些用户来说十分友好。</li>
</ul>
<h2 id="jep-345g1支持numa非统一内存访问">JEP 345：G1支持NUMA（非统一内存访问）</h2>
<p>G1 收集器现在可以感知 <code>NUMA</code> 内存分配方式，以提高 G1 的性能，可以使用 <code>+XX:+UseNUMA</code> 启用这项功能。</p>
<h2 id="jep-363-移除-cms-垃圾收集器">JEP 363： 移除 CMS 垃圾收集器</h2>
<p>移除对 CMS（Concurrent Mark Sweep） 垃圾收集器的支持，其实早在 Java 9 就开始移除 CMS 垃圾收集器了，只不过在 Java 14 中被正式删除。</p>
<h2 id="jep-364macos-上的-zgc实验性">JEP 364：macOS 上的 ZGC（实验性）</h2>
<p>Java 11 在 Linux 上引入了 Z 垃圾收集器 (ZGC)，现在它可以移植到 macOS。</p>
<h2 id="jep-365windows-上的-zgc实验性">JEP 365：Windows 上的 ZGC（实验性）</h2>
<p>Java 11 在 Linux 上引入了 Z 垃圾收集器 (ZGC)，现在它可以移植到 Windows 上（版本大于 1803）。</p>
<h2 id="jep-366弃用-parallelscavenge-serialold-gc-组合">JEP 366：弃用 ParallelScavenge + SerialOld GC 组合</h2>
<h2 id="jep-377zgc可扩展低延迟垃圾收集器">JEP 377：ZGC可扩展低延迟垃圾收集器</h2>
<p>ZGC 垃圾收集器在 Java 11 中被引入，但是因为收集器的复杂性，当初决定逐渐引入。然后不断的听取用户的反馈建议修复问题。而现在，已经很久没有收到用户的问题反馈了，ZGC 是时候投入正式使用阶段了。所以在 Java 15 中 ZGC 正式发布，可以使用下面的参数启用 ZGC。</p>
<pre><code class="language-shell">$ java -XX:+UseZGC className
</code></pre>
<h2 id="jep-376zgc-并发线程堆栈处理">JEP 376：ZGC 并发线程堆栈处理</h2>
<p>这次改动让 ZGC 线程堆栈处理从 <strong>安全点（Safepoints)</strong> 移动到并发阶段。</p>
<p>如果你忘记了什么是 Safepoints，可以复习一下。</p>
<p>我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 <strong>Stop The World</strong>。</p>
<p>而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做<strong>安全点（Safepoints）</strong>。</p>
<h2 id="支持unicode-11">支持Unicode 11</h2>
<p>在 Java 11 支持了 Unicode 10 之后， Java 12 支持了 Unicode 11，支持操作更多的表情、符号。</p>
<h2 id="jep-392打包工具">JEP 392：打包工具</h2>
<p>在 Java 14 中，引入了打包工具，命令是 <code>jpackage</code>，使用 <code>jpackage</code> 命令可以把 JAR 包打包成不同操作系统支持的软件格式。</p>
<pre><code class="language-shell">jpackage --name myapp --input lib --main-jar main.jar --main-class myapp.Main
</code></pre>
<p>常见平台格式如下：</p>
<ol>
<li>Linux: <code>deb</code> and <code>rpm</code></li>
<li>macOS: <code>pkg</code> and <code>dmg</code></li>
<li>Windows: <code>msi</code> and <code>exe</code></li>
</ol>
<p>要注意的是，<code>jpackage</code> 不支持交叉编译，也就是说在 windows 平台上是不能打包成 macOS 或者 Linux 系统的软件格式的。</p>
<p>下面是一个例子，把一个简单的 Java Swing 程序打包成当前操作系统支持的软件格式，然后安装到当前电脑。</p>
<p>编写 Java 代码</p>
<pre><code class="language-java">import javax.swing.*;
import java.awt.*;

public class JEP392 {

    public static void main(String[] args) {
        JFrame frame = new JFrame(&quot;Hello World Java Swing&quot;);
        frame.setMinimumSize(new Dimension(800, 600));
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        JLabel lblText = new JLabel(&quot;Hello World!&quot;, SwingConstants.CENTER);
        frame.getContentPane().add(lblText);
        frame.pack();
        frame.setVisible(true);

    }
}
</code></pre>
<p>编译后，创建一个 JAR 文件。</p>
<pre><code class="language-shell">$ javac JEP392.java
$ java JEP392.java
$ jar cvf JEP392.jar JEP392.class
</code></pre>
<p>将生成的 JEP392.jar 打包到符合当前平台的软件包中。</p>
<pre><code class="language-shell">$ ~/develop/jdk-16.0.1.jdk/Contents/Home/bin/jpackage -i . -n JEP392 --main-jar hello.jar --main-class JEP392
$ ll
-rw-r--r--@ 1 darcy  staff    50M 10 28 20:34 JEP392-1.0.dmg
-rw-r--r--  1 darcy  staff   864B 10 28 20:22 JEP392.class
-rw-r--r--  1 darcy  staff   1.0K 10 28 20:30 JEP392.jar
-rw-r--r--  1 darcy  staff   588B 10 28 20:22 JEP392.java
</code></pre>
<p><code>ll</code> 后显示的 <code>JEP392-1.0.dmg</code>（我用的 MacOS ，所以格式是 dmg）就是打包后的结果。</p>
<p>不同的系统安装位置不同：</p>
<ul>
<li>Linux： <code>/opt</code></li>
<li>MacOS ： <code>/Applications</code></li>
<li>Windows: <code>C:\Program Files\</code></li>
</ul>
<h2 id="jep-372移除nashorn-javascript引擎">JEP 372：移除Nashorn JavaScript引擎</h2>
<p>Nashorn JavaScript 引擎在 Java 8 中被引入，在 Java 11 中被标记为废弃。由于 ECMAScript 语言发展很快，维护 Nashorn JavaScript 的成本过于高昂，在 Java 15 中被彻底删除。</p>
<h2 id="jep-381-删除solaris和sparc端口">JEP 381: 删除Solaris和SPARC端口</h2>
<h2 id="jep-385废弃rmi激活机制">JEP 385:废弃RMI激活机制</h2>
<h2 id="jep-347-启用c14语言特性">JEP 347: 启用C++14语言特性</h2>
<p>这项更新和 Java 开发者关系不太密切，JEP 347 允许 在 JDK 的 C++ 源码中使用 C++ 14 的语言特性，并且给出了哪些特性可以在 HotSpot 代码中使用的具体说明。</p>
<h2 id="jep-357">JEP 357</h2>
<p>在此之前，OpenJDK 源代码是使用版本管理工具 Mercurial 进行管理的，你也可以在 <a href="http://hg.openjdk.java.net/">http://hg.openjdk.java.net/</a>查看 OpenJDK 的源代码历史版本。</p>
<p>但是现在迁移到了 GIt ，主要原因如下：</p>
<ol>
<li>Mercurial 生成的版本控制元数据过大。</li>
<li>Mercurial 相关的开发工具比较少，而 Git 几乎在所有的主流 IDE 中已经无缝集成。</li>
<li>Mercurial 相关的服务比较少，无论是自建托管，还是服务托管。</li>
</ol>
<p>为了优雅的迁移到 Git，OpenJDK 做了如下操作。</p>
<ol>
<li>将所有的单存储库 OpenJDK 项目从 Mercurial 迁移到 Git。</li>
<li>保留所有的版本控制历史，也包括 Tag。</li>
<li>根据 Git 的最佳实践重新格式化提交的消息。</li>
<li>创建了一个工具用来在 Mercurial 和 Git 哈希之间进行转换。</li>
</ol>
<h2 id="jep-369迁移到-github">JEP 369：迁移到 GitHub</h2>
<p>和 JEP 357 从 Mercurial 迁移到 Git 的改变一致，在把版本管理迁移到 Git 之后，选择了在 GitHub 上托管 OpenJDK 社区的 Git 仓库。不过只对 JDK 11 以及更高版本 JDK 进行了迁移。</p>
<h2 id="jep-380unix-域套接字通道">JEP 380：Unix 域套接字通道</h2>
<p>添加 UnixDomainSocketAddress.java 类用于支持 Unix 域套接字通道。</p>
<p>添加 Unix-domain socket 到 SocketChannel 和 ServerSocketChannel API 中。</p>
<p>添加枚举信息 java.net.StandardProtocolFamily.UNIX。</p>
<h2 id="jep-386移植-alpine-linux">JEP 386：移植 Alpine Linux</h2>
<p><strong>Apine Linux</strong> 是一个独立的、非商业的 Linux 发行版，它十分的小，一个容器需要不超过 8MB 的空间，最小安装到磁盘只需要大约 130MB 存储空间，并且十分的简单，同时兼顾了安全性。</p>
<p>此提案将 JDK 移植到了 Apline Linux，由于 Apline Linux 是基于 musl lib 的轻量级 Linux 发行版，因此其他 x64 和 AArch64 架构上使用 musl lib 的 Linux 发行版也适用。</p>
<h2 id="jep-387更好的-metaspace">JEP 387：更好的 Metaspace</h2>
<p>自从引入了 Metaspace 以来，根据反馈，Metaspace 经常占用过多的堆外内存，从而导致内存浪费，现在可以更及时地将未使用的 HotSpot class-metaspace 内存<em>返还</em>给操作系统，从而减少 Metaspace 的占用空间，并优化了 Metaspace 代码以降低后续的维护成本。</p>
<h2 id="jep-388移植-windowsaarch64">JEP 388：移植 Windows/AArch64</h2>
<p>将 JDK 移植到 Windows/AArch64 架构上，Windows/AArch64 已经是终端用户市场的热门需求。</p>
<h2 id="jep-403更强的-jdk-内部封装">JEP 403：更强的 JDK 内部封装</h2>
<p>为了提高 JDK 的安全性，使 <code>--illegal-access</code> 选项的默认模式从允许更改为拒绝。通过此更改，JDK 的内部包和 API（<a href="https://openjdk.java.net/jeps/260#Description">关键内部 API</a>除外）将不再默认打开。</p>
<p>但是在 Java 17 中，除了 <code>sun.misc.Unsafe</code> ，使用 <code>--illegal-access</code> 命令也不能打开 JDK 内部的强封装模式了，除了 <code>sun.misc.Unsafe</code> API .</p>
<p>在 Java 17 中使用 <code>--illegal-access</code> 选项将会得到一个命令已经移除的警告。</p>
<pre><code class="language-shell">➜  bin ./java -version
openjdk version &quot;17&quot; 2021-09-14
OpenJDK Runtime Environment (build 17+35-2724)
OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing)
➜  bin ./java --illegal-access=warn
OpenJDK 64-Bit Server VM warning: Ignoring option --illegal-access=warn; support was removed in 17.0
</code></pre>
<h2 id="jep-382使用新的-macos-渲染库">JEP 382：使用新的 macOS 渲染库</h2>
<p>macOS 为了提高图形的渲染性能，在 2018 年 9 月抛弃了之前的 OpenGL 渲染库 ，而使用了 Apple Metal 进行代替。Java 17 这次更新开始支持 Apple Metal，不过对于 API 没有任何改变，这一些都是内部修改。</p>
<h2 id="jep-391支持-macosaarch64-架构">JEP 391：支持 macOS/AArch64 架构</h2>
<p>起因是 Apple 在 2020 年 6 月的 WWDC 演讲中宣布，将开启一项长期的将 Macintosh 计算机系列从 x64 过度到 AArch64 的长期计划，因此需要尽快的让 JDK 支持 macOS/AArch64 。</p>
<h2 id="jep-398删除已弃用的-applet-api">JEP 398：删除已弃用的 Applet API</h2>
<p>Applet 是使用 Java 编写的可以嵌入到 HTML 中的小应用程序，嵌入方式是通过普通的 HTML 标记语法，由于早已过时，几乎没有场景在使用了。</p>
<p>示例：嵌入 Hello.class</p>
<pre><code class="language-html">&lt;applet code=&quot;Hello.class&quot; height=200 width=200&gt;&lt;/applet&gt;
</code></pre>
<p>Applet API 在 Java 9 时已经标记了废弃，现在 Java 17 中将彻底删除。</p>
<h2 id="jep-407移除-rmi-activation">JEP 407：移除 RMI Activation</h2>
<p>移除了在 JEP 385 中被标记废除的 RMI（Remote Method Invocation）Activation，但是 RMI 其他部分不会受影响。</p>
<h2 id="jep-410移除实验性的-aot-和-jit-编译器">JEP 410：移除实验性的 AOT 和 JIT 编译器</h2>
<p>在 Java 9 的 JEP 295 中，引入了实验性的提前编译 jaotc 工具，但是这个特性自从引入依赖用处都不太大，而且需要大量的维护工作，所以在 Java 17 中决定删除这个特性。</p>
<p>主要移除了三个 JDK 模块：</p>
<ol>
<li>jdk.aot - jaotc 工具。</li>
<li>Jdk.internal.vm.compiler - Graal 编译器。</li>
<li>jdk.internal.vm.compiler.management</li>
</ol>
<p>同时也移除了部分与 AOT 编译相关的 HotSpot 代码：</p>
<ol>
<li><code>src/hotspot/share/aot</code> — dumps and loads AOT code</li>
<li>Additional code guarded by <code>#if INCLUDE_AOT</code></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[k8s打怪升级之路---第一关，搭建一个简单的]]></title>
        <id>https://alexritian.github.io/post/k8s-da-guai-sheng-ji-zhi-lu-di-yi-guan-da-jian-yi-ge-jian-dan-de/</id>
        <link href="https://alexritian.github.io/post/k8s-da-guai-sheng-ji-zhi-lu-di-yi-guan-da-jian-yi-ge-jian-dan-de/">
        </link>
        <updated>2022-11-07T06:01:47.000Z</updated>
        <summary type="html"><![CDATA[<p>使用kubeadm搭建一个简单的k8s集群</p>
]]></summary>
        <content type="html"><![CDATA[<p>使用kubeadm搭建一个简单的k8s集群</p>
<!-- more -->
<h1 id="准备阶段">准备阶段</h1>
<h2 id="规划节点">规划节点</h2>
<p>准备linux服务器（配置随意，不能小于2C/2G 😜），规划哪些服务器作为master节点，那些作为node节点。<br>
我准备了4台服务器,一台作为master节点，2台作为node节点,有一台不加入集群的服务器作为部署节点。</p>
<blockquote>
<p>[!tip]<br>
部署节点不是必须的，集群中的任何节点都可以执行部署操作</p>
</blockquote>
<h3 id="节点名字可选">节点名字(可选)</h3>
<p>给每个节点起名字，然后将其配置到每个服务器的 <code>/etc/hosts</code></p>
<blockquote>
<p>[!tip]<br>
默认Pod不会调度到master节点，只会在node节点调度</p>
</blockquote>
<h2 id="下载安装包">下载安装包</h2>
<h3 id="containerd">containerd</h3>
<ul>
<li><a href="https://github.com/containerd/containerd/releases">containerd-releases</a> :<br>
从github现在最新release版本</li>
<li><a href="https://github.com/containerd/containerd/blob/main/containerd.service">containerd.service</a> 文件</li>
<li><a href="https://github.com/containerd/containerd/blob/main/go.mod">go.mod</a></li>
</ul>
<h3 id="runc">runc</h3>
<ul>
<li><a href="https://github.com/opencontainers/runc/releases">runc-releases</a></li>
</ul>
<h3 id="cni-plugin">cni-plugin</h3>
<ul>
<li><a href="https://github.com/containernetworking/plugins/releases">plugins-releases</a></li>
<li><a href="https://github.com/containerd/containerd/blob/main/script/setup/install-cni">初始化脚本</a></li>
</ul>
<h3 id="cilium">cilium</h3>
<ul>
<li><a href="https://github.com/cilium/cilium-cli/releases/">releases</a></li>
</ul>
<h3 id="hlem">hlem</h3>
<ul>
<li><a href="https://github.com/helm/helm/releases">releases</a></li>
</ul>
<h3 id="go">go</h3>
<ul>
<li><a href="https://go.dev/dl/go1.19.1.linux-amd64.tar.gz">Download</a></li>
</ul>
<h3 id="k9s">k9s</h3>
<ul>
<li><a href="https://github.com/derailed/k9s/releases">release</a></li>
</ul>
<h2 id="安装组件">安装组件</h2>
<p><em><strong>所有节点（服务器）都需要进行下列操作</strong></em></p>
<blockquote>
<p>[!tip]<br>
有条件的使用 <code>root</code> 用户进行下列操作，非root用户也是可以的，只是我是使用root进行的操作</p>
</blockquote>
<h3 id="install-go">install go</h3>
<ol>
<li><code>rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz</code></li>
<li>添加<code>export PATH=$PATH:/usr/local/go/bin</code>到<code>/etc/profile</code></li>
<li><code>source /etc/profile</code></li>
<li><code>go version</code></li>
</ol>
<p>执行下列命令</p>
<pre><code class="language-sh">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz
</code></pre>
<p>配置环境变量，添加下列内容到 <code>/etc/profile</code></p>
<pre><code>export PATH=$PATH:/usr/local/go/bin
</code></pre>
<p>执行下列命令使环境变量生效</p>
<pre><code class="language-sh">source /etc/profile
</code></pre>
<p>验证</p>
<pre><code class="language-sh">go version
</code></pre>
<h3 id="install-go-mod">install go mod</h3>
<blockquote>
<p>[!attention]<br>
我不懂GO，所以containerd go mod我是直接从github下载文件放到了go的目录中 😅</p>
</blockquote>
<pre><code class="language-sh">mkdir -p /usr/local/go/bin/src/github.com/containerd/containerd/
cp go.mod /usr/local/go/bin/src/github.com/containerd/containerd/
</code></pre>
<h3 id="install-containerd">install containerd</h3>
<p>解压[[#containerd|准备阶段]] 下载的 <code>containerd-x.x.x-llinux-amd64.tar.gz</code> 解压到 <code>/usr/local</code> 目录</p>
<pre><code class="language-sh">tar Cxzvf /usr/local containerd-1.6.8-linux-amd64.tar.gz
</code></pre>
<h3 id="install-runc">install runc</h3>
<p>通过下列命令将[[#runc#|准备阶段]] 下载的<code>runc.&lt;ARCH&gt;</code> 安装到<code>/user/sbin/</code> 目录</p>
<pre><code class="language-sh">install -m 755 runc.amd64 /usr/sbin/runc
</code></pre>
<h3 id="install-cni-plugin">install CNI plugin</h3>
<p>通过下列命令将[[#cni-plugin|准备阶段]] 下载的 <code>cni-plugins-xxx-xxx-vxxxx.tgz</code> 解压到 <code>/opt/cni/bin</code> 目录</p>
<pre><code class="language-sh">mkdir -p /opt/cni/bin
tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz
</code></pre>
<h3 id="install-kubeadm-kubelet-和-kubectl">install kubeadm、kubelet 和 kubectl</h3>
<pre><code class="language-sh">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

sudo setenforce 0
sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes

sudo systemctl enable --now kubelet
</code></pre>
<h2 id="进行配置">进行配置</h2>
<h3 id="关闭swap">关闭swap</h3>
<p>编辑 <code>/etc/fstab</code> 注释 swap 行</p>
<h3 id="配置iptables">配置iptables</h3>
<pre><code class="language-sh">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

sudo modprobe overlay
sudo modprobe br_netfilter

# 设置所需的 sysctl 参数，参数在重新启动后保持不变
cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

# 应用 sysctl 参数而不重新启动
sudo sysctl --system
</code></pre>
<h3 id="配置containerdservice">配置containerd.service</h3>
<p>将[[#准备阶段#containerd#|准备阶段]] 下载的<code>containerd.service</code>文件复制到<code>/usr/lib/systemd/system/</code>，然后执行下列命令：</p>
<pre><code class="language-sh">systemctl daemon-reload
systemctl enable --now containerd
</code></pre>
<h3 id="配置containerd">配置containerd</h3>
<h4 id="配置containerdservice-2">配置containerd.service</h4>
<p>将[[#准备阶段#containerd#|准备阶段]] 下载的<code>containerd.service</code>文件复制到<code>/usr/lib/systemd/system/</code>，然后执行下列命令：</p>
<pre><code class="language-sh">systemctl daemon-reload
systemctl enable --now containerd
</code></pre>
<p>通过下面命令生成containerd默认配置文件</p>
<pre><code class="language-sh">containerd config default &gt; /etc/containerd/config.toml
</code></pre>
<blockquote>
<p>[!tip]<br>
遇到<code>no such file or directory: /etc/containerd/config.toml</code>报错，通过下列命令创建目录</p>
<pre><code class="language-sh">mkdir -p /etc/containerd/
</code></pre>
<p>遇到<code>command not found: containerd</code>,查询 <code>containerd</code>位置</p>
<pre><code class="language-sh">whereis containerd
</code></pre>
<p>结果输出<code>containerd: /usr/local/bin/containerd</code>，将输出目录添加到<code>$PATH</code></p>
</blockquote>
<h4 id="配置国内镜像源">配置国内镜像源</h4>
<p>修改 <code>/etc/containerd/config.toml</code> 文件</p>
<p>修改sandbox_image的镜像</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;]
    sandbox_image = &quot;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6&quot;
</code></pre>
<p>修改registry的镜像源</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]
    endpoint = [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;, &quot;https://registry-1.docker.io&quot;]
[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;] 
    endpoint = [&quot;registry.aliyuncs.com/google_containers&quot;]
</code></pre>
<blockquote>
<p>[!tip]<br>
xxxx.mirror.aliyuncs.com 需要到阿里云注册获取，每个帐号有一个独立的地址。</p>
</blockquote>
<h4 id="配置-systemd-cgroup-驱动">配置 <code>systemd</code> cgroup 驱动</h4>
<p>在 <code>/etc/containerd/config.toml</code> 中设置 <code>SystemdCgroup</code> 为 <strong>true</strong></p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]
    SystemdCgroup = true
</code></pre>
<h4 id="重启-congtainerdservice">重启 congtainerd.service</h4>
<pre><code class="language-sh">sudo systemctl restart containerd
</code></pre>
<h3 id="初始化cni">初始化CNI</h3>
<p>执行[[#cni-plugin|准备阶段]] 下载的初始化cni的脚本</p>
<h1 id="启动阶段">启动阶段</h1>
<h2 id="master节点">master节点</h2>
<h3 id="初始化集群">初始化集群</h3>
<blockquote>
<p>[!tip]<br>
如果规划的master节点有多个，只需要在第一个master节点进行初始化</p>
</blockquote>
<p>通过下列命令初始化节点</p>
<pre><code class="language-sh">kubeadm init \
--control-plane-endpoint=&lt;domain name&gt; \
--image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \
--token= &lt;token&gt; \
--token-ttl=0 \
--apiserver-advertise-address=&lt;master ip&gt; \
--pod-network-cidr=10.0.0.0/16 \
--node-name=master
</code></pre>
<blockquote>
<p>[!note]<br>
<code>--control-plane-endopoint</code> : 配置control plane的域名，如果没有配置dns，需要在每个服务器上配置 <code>/etc/hosts</code><br>
<code>--image-repository</code> : 镜像源地址，我使用的阿里云的源<br>
<code>--token</code> ：配置集群的token，其他节点加入集群的时候使用, 格式： &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot;  不使用此参数会自动生成一个<br>
<code>--token-ttl</code> : token过期时间（例如 1 s，2 m，3 h），默认为 24h0m0s。如果设置为 '0'，则令牌将永不过期。<br>
<code>--apiserver-advertise-address</code> :  master 节点的IP地址<br>
<code>--pod-nwework-cidr</code> 这个是配置集群内部使用的网段<br>
<code>--node-name</code> 节点的名字(可以不添加此参数，默认为服务器的hostname)</p>
</blockquote>
<p>命令执行成功之后会有如下输出</p>
<pre><code>Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

Alternatively, if you are the root user, you can run:

  export KUBECONFIG=/etc/kubernetes/admin.conf

You should now deploy a pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  https://kubernetes.io/docs/concepts/cluster-administration/addons/

You can now join any number of control-plane nodes by copying certificate authorities
and service account keys on each node and then running the following as root:

  kubeadm join &lt;domain name&gt;:6443 --token &lt;token&gt; \
	--discovery-token-ca-cert-hash &lt;hash&gt; \
	--control-plane 

Then you can join any number of worker nodes by running the following on each as root:

kubeadm join &lt;domain name&gt;:6443 --token &lt;token&gt; \
	--discovery-token-ca-cert-hash &lt;sh256&gt;
</code></pre>
<blockquote>
<p>[!tip]<br>
输出中的<strong>jion</strong>命令，带有 <code>--control-plane</code> 参数的是添加master节点(管理节点)到集群中，另一个为添加node节点(work节点)到集群中。</p>
</blockquote>
<h3 id="生成cluster-config文件">生成cluster config文件</h3>
<pre><code class="language-sh">mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
</code></pre>
<h2 id="node节点">node节点</h2>
<p>通过下列命令把node节点加入集群</p>
<pre><code class="language-sh">kubeadm join \
&lt;master domin name&gt;:6443 \
--token &lt;token&gt; \
--discovery-token-ca-cert-hash &lt;hash256&gt; \
--node-name=node1
</code></pre>
<blockquote>
<p>[!tip]<br>
<code>&lt;master domain name&gt;</code> : 初始化集群的时候配置的 <code>--control-plane-endopoint</code> 参数的值<br>
<code>--token</code> : 初始化集群配置的token，直接复制初始化集群之后的输出内容中的 token使用即可<br>
<code>--discovery-token-ca-cert-hash</code> : 直接复制初始化集群之后的输出内容中的 hash使用即可<br>
<code>--node-name</code> : 节点的名字(可以不添加此参数，默认为服务器的hostname)</p>
</blockquote>
<h1 id="配置部署节点">配置部署节点</h1>
<h2 id="copy-cluster-config文件到部署节点">copy cluster config文件到部署节点</h2>
<pre><code class="language-sh">mkdir -p $HOME/.kube
cp config $HOME/.kube/
</code></pre>
<blockquote>
<p>[!tipe]<br>
config文件来自master节点，目录在执行初始化集群操作的用户的 <code>$HOME/.kube/</code> 目录<br>
如果选择在执行初始化集群命令的服务器上进行部署操作，可以跳过这步。<br>
如果选择在其他节点的服务器上进行部署操作，需要执行此步</p>
</blockquote>
<h2 id="install-kubectl">install kubectl</h2>
<p>参考 [[#install kubeadm、kubelet 和 kubectl|安装组件]] 安装kubectl</p>
<h2 id="install-helm">install helm</h2>
<pre><code class="language-sh">tar -zxvf helm-v3.0.0-linux-amd64.tar.gz
mv linux-amd64/helm /usr/local/bin/helm
</code></pre>
<blockquote>
<p>[!tip]<br>
有些虚机可能没有将 <code>/usr/local/bin</code> 目录加入到 <code>$PATH</code></p>
</blockquote>
<h2 id="install-k9s">install k9s</h2>
<ol>
<li>解压</li>
<li>copy k9s to /usr/local/bin</li>
</ol>
<h1 id="部署应用">部署应用</h1>
<h2 id="网络组件">网络组件</h2>
<h3 id="install-cilium">install cilium</h3>
<pre><code class="language-sh">sudo tar xzvfC cilium-linux-${CLI_ARCH}.tar.gz /usr/local/bin
cilium install
</code></pre>
<p>查看一下状态</p>
<pre><code class="language-sh">cilium status
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://alexritian.github.io/post-images/1667801122358.png" alt="" loading="lazy"></figure>
<h2 id="测试用例">测试用例</h2>
<h3 id="部署busybox">部署busybox</h3>
<p>创建一个 <code>busybox.yaml</code> 文件,将下列内容写入文件中</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: busybox
  labels:
    app: guestbook
    tier: busybox
spec:
  replicas: 2
  selector:
    matchLabels:
      tier: busybox
  template:
    metadata:
      labels:
        tier: busybox
    spec:
      containers:
      - name: busybox
        image: busybox:1.28
        command:
          - sleep
          - &quot;3600&quot;
        imagePullPolicy: IfNotPresent
      restartPolicy: Always

</code></pre>
<p>执行下列命令，部署busybox到集群中</p>
<pre><code class="language-sh">kubectl apply -f busybox.yaml
</code></pre>
<h1 id="检查集群状态">检查集群状态</h1>
<p>通过<strong>k9s</strong>查看并测试集群</p>
<p>执行命令，进入k9s界面。</p>
<pre><code class="language-sh">k9s
</code></pre>
<h2 id="查看节点状态">查看节点状态</h2>
<p>按 <code>ESC</code>,然后 按 <code>：</code>，然后输入 <code>node</code>, 然后按 <code>Enter</code>。  然后看看 <code>STATUS</code> 列是否都是 <code>Ready</code>。</p>
<figure data-type="image" tabindex="2"><img src="https://alexritian.github.io/post-images/1667801331436.png" alt="" loading="lazy"></figure>
<h2 id="查看-pod状态">查看 Pod状态</h2>
<p>进入k9s之后，按<code>：</code>，然后输入 <code>pods</code>,然后按 <code>enter</code> ， 然后按 <code>0</code>,就可以看到类似下面的内容. 查看 <code>READY</code> 和 <code>STATUS</code> 是否正常。</p>
<blockquote>
<p>[!info]<br>
k9s的详细操作，可以参考<a href="https://k9scli.io/">官网</a>.</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://alexritian.github.io/post-images/1667801528966.png" alt="" loading="lazy"></figure>
<h2 id="检查集群内部网络">检查集群内部网络</h2>
<p>通过方向键选中 <code>busybox</code> 的pod，NAME以 <code>busybox</code>开头。然后按 <code>S</code> 进入pod shell。 (需要提前记录一下另一个 busybox的 IP)</p>
<blockquote>
<p>[!tip]<br>
<code>IP</code> 列展示的是Pod在集群内部的IP地址</p>
</blockquote>
<pre><code class="language-sh">ping 10.0.0.44 -c 4
</code></pre>
<pre><code>PING 10.0.0.44 (10.0.0.44): 56 data bytes
64 bytes from 10.0.0.44: seq=0 ttl=63 time=0.974 ms
64 bytes from 10.0.0.44: seq=1 ttl=63 time=0.684 ms
64 bytes from 10.0.0.44: seq=2 ttl=63 time=0.702 ms
64 bytes from 10.0.0.44: seq=3 ttl=63 time=0.659 ms

--- 10.0.0.44 ping statistics ---
4 packets transmitted, 4 packets received, 0% packet loss

</code></pre>
<h1 id="搞定"><em><strong>搞定</strong></em></h1>
<!-- more -->
]]></content>
    </entry>
</feed>