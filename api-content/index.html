{"posts":[{"title":"RASA初体验---构建一个人工智障","content":"使用RASA构建一个聊天机器人demo 准备工作 [!attention] 需要docker环境，如果没有docker，请先安装好docker。 制作镜像 [!tip] 因为要使用jieba分词，官方的镜像没有预装jieba分词的模块，所以需要制作一个带有jieba分词的docker镜像 编辑 Dockerfile 文件 FROM rasa/rasa:latest-full USER root RUN pip install jieba USER 1001 build镜像 docker build -t rasa-jieba . [!note] 执行命令和 Dockerfile 不在同一个目录，命令中的 . 需要替换为 Dockerfile 文件的路径 下载jieba分词词典 jieba词典 （我使用的是 dict.txt.big ) 初始化模型 docker run -it -v /data/ai/rasa_data/:/app rasa-jieba init [!tip] /app 是rasa默认使用的目录，模型相关文件都在这个目录 编辑模型文件 [!tip] RASA 默认支持英文和德文，如果要使用中文需要对初始化的模型文件进行修改 data/nul.yml 这是训练数据，intent 是用户意图，examples 是训练数据 version: &quot;3.0&quot; nlu: - intent: greet examples: | - 你好 - 您好 - 早上好 - 下午好 - intent: inform examples: | - 我想订一张去北京的机票 - 明天北京天气怎么样 - 北京有哪些好玩的地方 - 我要预定一个酒店 - intent: book_flight examples: | - 我要订一张从[上海](origin)到[北京](destination)的机票 - 我要预定明天从[南京](origin)到[广州](destination)的航班 - 我想要从[北京](origin)飞往[香港](destination) - 我需要订一张从[深圳](origin)到[上海](destination)的机票 - 我想订一张从[杭州](origin)到[成都](destination)的航班 - 我想买一张从[重庆](origin)到[西安](destination)的机票 - 我要预订[上海](destination)到[北京](origin)的机票 - 我需要乘坐[深圳](origin)到[北京](destination)的航班 - 我想要订一张从[上海](origin)到[成都](destination)的机票 - 请帮我预订从[广州](origin)飞往[北京](destination)的机票 - intent: check_weather examples: | - 明天[北京](location)的天气怎么样？ - [上海](location)会下雨吗？ - [广州](location)最高温度会是多少？ - intent: recommend_place examples: | - 北京有哪些好玩的地方？ - 能给我推荐一些适合家庭旅游的地方吗？ - 哪里有好吃的北京烤鸭？ - intent: book_hotel examples: | - 我要预订一间酒店 - 给我预定一间在[北京](location)的酒店 - [上海](location)有哪些不错的酒店？ - intent: bot_challenge examples: | - 你是机器人吗？ - 你是人工智能吗？ - 你是人吗？ - 你是人类吗？ entity: - location - origin - destination domain.yml responses 是bot反馈内容 version: &quot;3.0&quot; intents: - greet - inform - book_flight - check_weather - recommend_place - book_hotel - bot_challenge responses: utter_greet: - text: &quot;你好，我是rasa-jieba&quot; utter_give_inform: - text: &quot;我将搜索相关信息,推荐去[北京]游玩&quot; utter_ask_if_need_book_flight: - text: &quot;是否需要我帮您订机票&quot; utter_ask_name: - text: &quot;请体提供您的姓名&quot; utter_give_weather: - text: &quot;天气晴朗&quot; utter_goodbye: - text: &quot;Bye&quot; utter_iamabot: - text: &quot;我是个人工智障.&quot; session_config: session_expiration_time: 60 carry_over_slots_to_new_session: true data/stories.yml 客户故事文件，定义 story version: &quot;3.0&quot; stories: - story: greet and bot challenge steps: - intent: greet - action: utter_greet - intent: bot_challenge - action: utter_iamabot - story: ask weather steps: - intent: greet - action: utter_greet - intent: check_weather - action: utter_give_weather - story: book flight steps: - intent: greet - action: utter_greet - intent: recommend_place - action: utter_give_inform - action: utter_ask_if_need_book_flight data/rules.yml version: &quot;3.0&quot; rules: - rule: Say 'I am a bot' anytime the user challenges steps: - intent: bot_challenge - action: utter_iamabot - rule: boot flight anytime steps: - intent: book_flight - action: utter_ask_name config.yml language: &quot;zh&quot; pipeline: - name: JiebaTokenizer dictionary_path: &quot;data/dict.txt.big&quot; - name: EntitySynonymMapper - name: RegexFeaturizer - name: CountVectorsFeaturizer - name: CountVectorsFeaturizer analyzer: &quot;char_wb&quot; min_ngram: 1 max_ngram: 4 - name: DIETClassifier epochs: 100 - name: ResponseSelector epochs: 100 - name: FallbackClassifier threshold: 0.3 ambiguity_threshold: 0.1 policies: # # No configuration for policies was provided. The following default policies were used to train your model. # # If you'd like to customize them, uncomment and adjust the policies. # # See https://rasa.com/docs/rasa/policies for more information. # - name: MemoizationPolicy # - name: RulePolicy # - name: UnexpecTEDIntentPolicy # max_history: 5 # epochs: 100 # - name: TEDPolicy # max_history: 5 # epochs: 100 # constrain_similarities: true [!tip] JiebaTokenizer 是jieba中文分词器 dictionary_path 指定词典文件，将其替换为前面下载的词典文件 训练模型 docker run -it -v /data/ai/rasa_data/:/app rasa-jieba train 与模型对话 docker run -it -v /data/ai/rasa_data/:/app -e LOG_LEVEL=DEBUG -p 5005:5005 rasa-jieba shell [!tip] -e LOG_LEVEL=DEBUG 开启debug级别的日志，如果不需要debug日志，可以去掉。 结语 到此一个非常非常非常简单的聊天机器人就构建好了，迈出了第一步。 ","link":"https://alexritian.github.io/post/rasa-chu-ti-yan-gou-jian-yi-ge-ren-gong-zhi-zhang/"},{"title":"使用Docker启动TansorFlow","content":"使用Docker部署tansorFlow和juypter server 下载 TensorFlow Docker 映像 官方 TensorFlow Docker 映像位于 tensorflow/tensorflow Docker Hub 代码库中。映像版本按照以下格式进行标记： 标记 说明 latest TensorFlow CPU 二进制映像的最新版本。（默认版本） nightly TensorFlow 映像的每夜版。（不稳定） version 指定 TensorFlow 二进制映像的版本，例如：2.1.0 devel TensorFlow master 开发环境的每夜版。包含 TensorFlow 源代码。 custom-op 用于开发 TF 自定义操作的特殊实验性映像。详见此处。 每个基本标记都有会添加或更改功能的变体： 标记变体 说明 tag-gpu 支持 GPU 的指定标记版本。（详见下文） tag-jupyter 针对 Jupyter 的指定标记版本（包含 TensorFlow 教程笔记本） 您可以一次使用多个变体。例如，以下命令会将 TensorFlow 版本映像下载到计算机上： docker pull tensorflow/tensorflow # latest stable release docker pull tensorflow/tensorflow:devel-gpu # nightly dev release w/ GPU support 启动镜像 docker run -d -p 8888:8888 tensorflow/tensorflow:latest-jupyter [!tip] 此命令会启动tensorflow和jupyter server， 8888端口为jupyter server端口 登陆jupter server 查看镜像启动后的日志 , 通过 日志用的 url访问jupyter. [I 03:06:03.714 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secret [I 03:06:03.949 NotebookApp] Serving notebooks from local directory: /tf [I 03:06:03.949 NotebookApp] Jupyter Notebook 6.4.5 is running at: [I 03:06:03.949 NotebookApp] http://271621135e5c:8888/?token=&lt;token&gt; [I 03:06:03.949 NotebookApp] or http://127.0.0.1:8888/?token=f&lt;token&gt; [I 03:06:03.949 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). [C 03:06:03.952 NotebookApp] To access the notebook, open this file in a browser: file:///root/.local/share/jupyter/runtime/nbserver-1-open.html Or copy and paste one of these URLs: http://271621135e5c:8888/?token=f&lt;token&gt; or http://127.0.0.1:8888/?token=f&lt;token&gt; ![[Pasted image 20230214111125.png]] http://127.0.0.1:8888/?token=f7fb7f4a869330c9bc7e10c06c9561bf3ffc78598c2648f1 ","link":"https://alexritian.github.io/post/shi-yong-docker-qi-dong-tansorflow/"},{"title":"搭建简单的openstack体验环境","content":"使用 kolla-ansible 搭建一个极简的openstack环境，体验一下openstack。本文是参考 kolla-ansible官方文档 进行搭建 需要提前了解 docker 和 ansible 。 准备 一台物理机或者虚拟机，本着节约资源的目的是用一台机器来搭建环境 2 network interfaces // 需要一个网卡绑定IP，另一个不绑定IP 8GB main memory 40GB disk space 2 IP address // 其中一个先不绑定到网卡上，预留出来就好 安装依赖 [!tip] 本次使用的是ubuntu 20.04操作系统，其他系统请使用相应的包管理器进行依赖安装 sudo apt update sudo apt install git python3-dev libffi-dev gcc libssl-dev 使用虚拟环境 [!tip] 官方推荐使用虚拟环境进行操作，避免依赖包和系统依赖包冲突 不使用虚拟环境可跳过此步骤 安装虚拟环境 sudo apt install python3-venv 创建并激活虚拟环境 python3 -m venv /path/to/venv source /path/to/venv/bin/activate 更新 pip pip install -U pip 安装 ansible pip install 'ansible&gt;=4,&lt;6' 安装 kolla-ansible [!tip] 如果未使用虚拟环境，请替换命令中的path install kolla-ansible pip install git+https://opendev.org/openstack/kolla-ansible@master [!warning] koll-ansible 15.0.0 不支持 Rocky linux 8 , 必须是Rocky linux 9 如果是使用Rocky linux 8 , 可以通过下列命令安装低版本的 kolla-ansible。 pip install kolla-ansible==14.7.0 创建 /etc/kolla 目录 sudo mkdir -p /etc/kolla sudo chown $USER:$USER /etc/kolla 复制配置文件到 /etc/kolla 目录 cp -r /path/to/venv/share/kolla-ansible/etc_examples/kolla/* /etc/kolla 复制 all-in-one inventory 文件到操作目录 cp /path/to/venv/share/kolla-ansible/ansible/inventory/all-in-one . [!note] 操作目录可以随便指定 all-in-one 默认是配置的loaclhost。会在当前机器搭建环境。 如果想在其他机器搭建环境，需要修改 all-in-one 中的hosts为服务器 ip，如果root禁止ssh登陆，需要指定 username 安装 Anisble Galaxy 依赖 kolla-ansible install-deps 准备初始化配置 生成 kolla password kolla-genpwd 修改 gloable.yml 配置文件 默认镜像 kolla_base_distro: &quot;rocky&quot; [!tip] 可选值如下 CentOS Stream (centos) Debian (debian) Rocky (rocky) Ubuntu (ubuntu) 网络 network_interface: &quot;eth0&quot; neutron_external_interface: &quot;eth1&quot; kolla_internal_vip_address: &quot;10.1.0.250&quot; [!tip] network_interface - 需要填写绑定了IP地址的网卡的网口名字 neutron_external_interface - 需要填写未绑定IP地址的网卡的网口名字 kolla_internal_vip_address - 需要填写提前预留的 IP地址，不能是服务器绑定的IP 启用服务 因为是极简安装，全部使用默认的配置 部署openstack 部署 bootstrap-server和kolla依赖 kolla-ansible -i ./all-in-one bootstrap-servers 校验 kolla-ansible -i ./all-in-one prechecks 部署openstack kolla-ansible -i ./all-in-one deploy 使用 openstack 安装 openstack CLI pip install python-openstackclient -c https://releases.openstack.org/constraints/upper/master 生成 admin配置文件 kolla-ansible post-deploy [!tip] 文件会生成在 /etc/kolla/admin-openrc.sh 这个脚本中有admin的帐号和密码。 访问 openstack dashbord， http://kolla_internal_vip_address/ 搞定！！！ ","link":"https://alexritian.github.io/post/da-jian-jian-dan-de-openstack-ti-yan-huan-jing/"},{"title":"k8s打怪升级之路---第二关,安装监控组件---metrics-server","content":"简单的集群搭建起来了，通过k9s可以方便的访问和管理集群了，但是k9s上的cpu和memory数据总是N/A。 给集群安装metrics-server让k9s可以读取到集群的资源使用情况。 安装 通过helm安装metrics-server 下载chart文件 helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/ helm pull metrics-server/metrics-server --version 3.8.2 [!tip] 网络好的可以不需要pull chat文件，直接执行install命令即可，install命令最后的 . 替换为 metrics-server/metrics-server install chart 解压chart文件，然后进入解压后的目录，执行下列命令 helm install metrics-server . 安装完成之后，我们进入k9s 的界面就能够看到CPU，MEM的使用率了。 配置集群 Context名字（可选） 因为我的k9s是安装在部署服务器(非k8s集群服务器)，我将多个k8s集群的config 文件都拷贝到部署服务器方便使用k9s进行操作。 在切换不同的集群的时候，发现k9s中显示的Context,Cluster,User都是一样的，有时候会分不清具体是在操作哪个集群。 搜索了一下发现，Context 的值比较容易修改，不需要对集群进行改动。 执行命令修改当前 config 文件中的 context 的值 kubectl config rename-context old-name new-name 修该完成之后再次进入 k9s 可以看到 Context 的值已经变为我们定义的名字，这样就方便的知道当前正在操作的是哪个集群了。 ","link":"https://alexritian.github.io/post/k8s-da-guai-sheng-ji-zhi-lu-di-er-guan-an-zhuang-jian-kong-zu-jian-metrics-server/"},{"title":"chrome添加私有CA证书(ubuntu版）","content":"ubuntu系统中chrome浏览器添加私有CA证书 在ubuntu上通过chrome访问公司内网服务器，总是提示证书不授信。将CA证书添加到授信列表后，还是提示不授信。 尝试通过 curl -vvl 访问域名，可以看到 SSL certificate verify ok. 此时需手动将CA证书添加到chrome证书管理中 打开chrome settings -&gt; Privacy and Security -&gt; Security -&gt; Manage certificates 点击 Authorities 标签页 点击 import 按钮，然后选择CA证书。 再次访问网站，就不会提示证书不授信了。 ","link":"https://alexritian.github.io/post/chrome-tian-jia-si-you-ca-zheng-shu-ubuntu-ban/"},{"title":"部署Chatwoot到kubernetes","content":"Chatwoot是一款开源在线聊天工具，记录一下如何部署chatwoot到kubernetes chatwoot 开源在线聊天工具（open source live chat) 部署chatwoot到k8s集群，记录一下部署过程。 deploy perpare 创建命令空间（可选） kubectl create namespace chatwoot 创建StoreageClass [!tip] chatwoot 需要使用redis和pgsql，如果已经有redis和pgsql环境或者实例可以直接跳到 [[#deploy to k8s]] chatwoot-pgsql-storageclass.yaml apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: chatwoot-pgsql-storageclass provisioner: kubernetes.io/no-provisioner reclaimPolicy: Retain chatwoot-redis-storageclass apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: chatwoot-redis-storageclass provisioner: kubernetes.io/no-provisioner reclaimPolicy: Retain [!note] 因为我使用的是nfs，集群没有内置的nfs provisioner。我这里就设置为no-provisioner 创建PV chatwoot需要使用3个PV，默认大小为8G。 chatwoot-pgsql-pv.yaml apiVersion: v1 kind: PersistentVolume metadata: name: chatwoot-postgres-pv spec: capacity: storage: 8Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain storageClassName: &quot;chatwoot-pgsql-storageclass&quot; nfs: path: &lt;nfs path&gt; server: &lt;nfs server ip&gt; chatwoot-redis-pv.yaml apiVersion: v1 kind: PersistentVolume metadata: name: chatwoot-redis-pv spec: capacity: storage: 8Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain storageClassName: &quot;chatwoot-redis-storageclass&quot; nfs: path: &lt;nfs path&gt; server: &lt;nfs server ip&gt; chatwoot-radis-pv.yaml apiVersion: v1 kind: PersistentVolume metadata: name: chatwoot-rails-pv spec: capacity: storage: 8Gi accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Retain storageClassName: &quot;chatwoot-redis-storageclass&quot; nfs: path: &lt;nfs path&gt; server: &lt;nfs server ip&gt; deploy to k8s 添加helm repo helm repo add chatwoot https://chatwoot.github.io/charts 拉取chart文件 helm pull chatwoot/chatwoot 解压缩 编辑charts/postgresql/values.yaml文件,修改 global.storageClass的值为准备阶段创建的storageClass的名字 ## @section Global parameters ## Please, note that this will override the parameters, including dependencies, configured to use the global value ## global: ## @param global.storageClass Global StorageClass for Persistent Volume(s) ## storageClass: &quot;chatwoot-pgsql-storageclass&quot; 编辑charts/redis/values.yaml文件，修改 global.storageClass的值为准备阶段创建的storageClass的名字 ## @section Global parameters ## Global Docker image parameters ## Please, note that this will override the image parameters, including dependencies, configured to use the global value ## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass ## ## @param global.imageRegistry Global Docker image registry ## @param global.imagePullSecrets Global Docker registry secret names as an array ## @param global.storageClass Global StorageClass for Persistent Volume(s) ## @param global.redis.password Global Redis&amp;reg; password (overrides `auth.password`) ## global: storageClass: &quot;chatwoot-pgsql-storageclass&quot; [!tip] 可以动态为chatwoot制备PV，这个我还不会 开启帐号注册(可选) 编辑chart文件根目录下的values.yaml文件，也可以通过在安装命令中增加参数来配置。 env: ENABLE_ACCOUNT_SIGNUP: true [!tip] 这里还有一个值 FRONTEND_URL ， 这个是配置chatwoot的url，默认值为 http://0.0.0.0:3000. 这个url会在集成chatwoot的时候使用，配置了之后 chatwoot自动生成的代码就不需要修改了。如果不配置，需要将自动生成的代码中的 http://0.0.0.0:3000 替换为集群的IP和chatwoot暴露出来的端口号。 下面是配置SMTP的，如果需要邮件服务需要配置SMTP。 注册帐号需要邮箱认证，不配置SMTP无法发送认证邮件。 SMTP_ADDRESS: &quot;&quot; SMTP_AUTHENTICATION: plain SMTP_ENABLE_STARTTLS_AUTO: true SMTP_OPENSSL_VERIFY_MODE: none SMTP_PASSWORD: &quot;&quot; SMTP_PORT: 587 SMTP_USERNAME: &quot;&quot; install chart helm install chatwoot . -n chatwoot config 创建超级管理员帐号 需要进入 chatwoot-web pod执行下列命令， 密码必须包含大写字母，小写字母，数字和特殊字符 // 进入 rails RAILS_ENV=production bundle exec rails c // 创建管理员帐号 SuperAdmin.create!(email: &quot;&lt;email address&gt;&quot;, password: &quot;&lt;password&gt;&quot; , name: &quot;&lt;name&gt;&quot; ) admin = User.where(email: '&lt;email address&gt;', type: 'SuperAdmin').first // 邮箱确认 admin.confirm // 保存 admin.save [!tip] 超级管理员地址： http://ip:port/super_admin ","link":"https://alexritian.github.io/post/bu-shu-chatwoot-dao-kubernetes/"},{"title":"Java12-Java17新特性","content":"从网上收集整理Java12-Java17的非预览，非孵化的特性 参考文章 OpenJDK Java 17 下载 OpenJDK Java 17 文档 https://www.wdbyte.com/java/java-17/ https://docs.oracle.com/en/java/javase/17/ 编码相关(非预览) 文件对比 Files.mismatch 对比两个文件，如果内容一致，会返回 -1 ，如果内容不同，会返回不同的字节开始位置。 // 创建两个文件 Path pathA = Files.createFile(Paths.get(&quot;a.txt&quot;)); Path pathB = Files.createFile(Paths.get(&quot;b.txt&quot;)); // 写入相同内容 Files.write(pathA,&quot;abc&quot;.getBytes(), StandardOpenOption.WRITE); Files.write(pathB,&quot;abc&quot;.getBytes(), StandardOpenOption.WRITE); long mismatch = Files.mismatch(pathA, pathB); System.out.println(mismatch); // 追加不同内容 Files.write(pathA,&quot;123&quot;.getBytes(), StandardOpenOption.APPEND); Files.write(pathB,&quot;321&quot;.getBytes(), StandardOpenOption.APPEND); mismatch = Files.mismatch(pathA, pathB); System.out.println(mismatch); // 删除创建的文件 pathA.toFile().deleteOnExit(); pathB.toFile().deleteOnExit(); // RESULT // -1 // 3 Compact Number 简化的数字格式可以直接转换数字显示格式，比如 1000 -&gt; 1K，1000000 -&gt; 1M 。 System.out.println(&quot;Compact Formatting is:&quot;); NumberFormat upvotes = NumberFormat.getCompactNumberInstance(new Locale(&quot;en&quot;, &quot;US&quot;), Style.SHORT); System.out.println(upvotes.format(100)); System.out.println(upvotes.format(1000)); System.out.println(upvotes.format(10000)); System.out.println(upvotes.format(100000)); System.out.println(upvotes.format(1000000)); // 设置小数位数 upvotes.setMaximumFractionDigits(1); System.out.println(upvotes.format(1234)); System.out.println(upvotes.format(123456)); System.out.println(upvotes.format(12345678)); 输出： 100 1K 10K 100K 1M 1.2K 123.5K 12.3M JEP 353：重新实现Socket API java.net.Socket 和 java.net.ServerSocket 类早在 Java 1.0 时就已经引入了，它们的实现的 Java 代码和 C 语言代码的混合，维护和调试都十分不易；而且这个实现还存在并发问题，有时候排查起来也很困难。 因此，在 Java 13 中引入了新的实现方式，使用了新的实现 NioSocketImpl 来代替老旧的 PlainSocketImpl 实现。虽然功能相同，但是老的方式在当前以及未来几个版本内不会删除，用户随时可以通过 -Djdk.net.usePlainSocketImpl 参数切换回老的实现方式，以兼容意外情况。 import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; public class Test { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(8000)){ boolean running = true; while(running){ Socket clientSocket = serverSocket.accept(); //do something with clientSocket } } catch (IOException e) { e.printStackTrace(); } } } 使用 Java 13 运行，通过参数 -XX:+TraceClassLoading 追踪加载的类，日志中可以看到 NioSocketImpl。 ➜ develop ./jdk-13.0.2.jdk/Contents/Home/bin/java -XX:+TraceClassLoading Test.java | grep SocketImpl [0.699s][info ][class,load] java.net.SocketImpl source: jrt:/java.base [0.699s][info ][class,load] java.net.SocketImpl$$Lambda$173/0x0000000800c37440 source: java.net.SocketImpl [0.702s][info ][class,load] sun.net.PlatformSocketImpl source: jrt:/java.base [0.702s][info ][class,load] sun.nio.ch.NioSocketImpl source: jrt:/java.base [0.713s][info ][class,load] sun.nio.ch.NioSocketImpl$FileDescriptorCloser source: jrt:/java.base 但在 Java 12 并不是 NioSocketImpl。 ➜ develop ./jdk-12.0.2.jdk/Contents/Home/bin/java -XX:+TraceClassLoading Test.java | grep SocketImpl [0.665s][info ][class,load] java.net.SocketImpl source: jrt:/java.base [0.665s][info ][class,load] java.net.AbstractPlainSocketImpl source: jrt:/java.base [0.665s][info ][class,load] java.net.PlainSocketImpl source: jrt:/java.base [0.665s][info ][class,load] java.net.SocksSocketImpl source: jrt:/java.base [0.666s][info ][class,load] java.net.AbstractPlainSocketImpl$1 source: jrt:/java.base JEP 358：更有用的NullPointerExceptions NullPointerException 一直都是一个比较常见的异常，但是在 Java 14 之前，如果一行有多个表达式时，这时报了空指针后，单纯的从报错信息来看，可能并不知道是哪个对象为 NULL ，下面是一个演示。 package com.wdbyte; public class Java14NullPointerExceptions { public static void main(String[] args) { String content1 = &quot;www.wdbyte.com&quot;; String content2 = null; int length = content1.length() + content2.length(); System.out.println(length); } } 在 Java 14 之前，从下面的报错中我们只能得到错误出现的行数，但是并不能确定是 conteng1 还是 content2 为 null。 Exception in thread &quot;main&quot; java.lang.NullPointerException at com.alibaba.security.astralnet.console.controller.ApiChartsTest.main(Java14NullPointerExceptions.java:8) 但是在 Java 14 中，会清晰的告诉你 because &quot;content2&quot; is null 。 Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.length()&quot; because &quot;content2&quot; is null at com.wdbyte.Java14NullPointerExceptions.main(Java14NullPointerExceptions.java:8) JEP 361: Swtich表达式（标准） Switch 表达式改进从 Java 12 就已经开始了，[[Java 12 新功能#Switch 表达式（JEP 325 （预览）|Java 12 让 switch 支持了 L-&gt; 语法]]，[[Java 13 新功能#Switch表达式 二次预览 （JEP 354|Java 13 引入了 yield 关键词用于返回结果]]，但是在 Java 12 和 13 中功能都是预览版的，而在 Java 14 中，正式转正。 // 通过传入月份，输出月份所属的季节 public static String switchJava12(String month) { return switch (month) { case &quot;march&quot;, &quot;april&quot;, &quot;may&quot; -&gt; &quot;春天&quot;; case &quot;june&quot;, &quot;july&quot;, &quot;august&quot; -&gt; &quot;夏天&quot;; case &quot;september&quot;, &quot;october&quot;, &quot;november&quot; -&gt; &quot;秋天&quot;; case &quot;december&quot;, &quot;january&quot;, &quot;february&quot; -&gt; &quot;冬天&quot;; default -&gt; &quot;month erro&quot;; }; } // 通过传入月份，输出月份所属的季节 public static String switchJava13(String month) { return switch (month) { case &quot;march&quot;, &quot;april&quot;, &quot;may&quot;: yield &quot;春天&quot;; case &quot;june&quot;, &quot;july&quot;, &quot;august&quot;: yield &quot;夏天&quot;; case &quot;september&quot;, &quot;october&quot;, &quot;november&quot;: yield &quot;秋天&quot;; case &quot;december&quot;, &quot;january&quot;, &quot;february&quot;: yield &quot;冬天&quot;; default: yield &quot;month error&quot;; }; } JEP 339：爱德华曲线算法(EdDSA) Java 15 中增加了一个新的密码学算法，爱德华曲线算法（EdDSA）签名算法。它是由 Schnorr 算法发展而来，在 RFC8032 中被定义实现。 package com.wdbyte; import java.nio.charset.StandardCharsets; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.Signature; import java.security.SignatureException; import java.util.Base64; public class JEP339 { public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException { KeyPairGenerator kpg = KeyPairGenerator.getInstance(&quot;Ed25519&quot;); KeyPair kp = kpg.generateKeyPair(); byte[] msg = &quot;www.wdbyte.com&quot;.getBytes(StandardCharsets.UTF_8); Signature sig = Signature.getInstance(&quot;Ed25519&quot;); sig.initSign(kp.getPrivate()); sig.update(msg); byte[] s = sig.sign(); System.out.println(Base64.getEncoder().encodeToString(s)); } } 输出结果： VXlpxapU+LSWjVQ0QNJvdpUh6VI6PjSwOQ2pHu65bCfnLR13OyWKunlc9rc+7SMxCh2Mnqf7TmC/iOG8oimbAw== JEP 371：Hidden Classes(隐藏类) 这个特性让开发者可以引入一个无法被其他地方发现使用，且类的生命周期有限的类。这对运行时动态生成类的使用方式十分有利，可以减少内存占用，下面是一个使用示例。 package com.wdbyte; public class JEP371Test { public static String lookup() { return &quot;www.wdbyte.com&quot;; } } 把类 JEP371Test 编译后的 Class 转换成 Base64，然后使用 Java 15 新特性加载调用类中的 lookup 方法。 package com.wdbyte; import java.lang.invoke.MethodHandle; import java.lang.invoke.MethodHandles; import java.lang.invoke.MethodType; import java.util.Base64; /** * @author www.wdbyte.com */ public class JEP371 { private static String CLASS_INFO = &quot;yv66vgAAADQAFAoAAgADBwAEDAAFAAYBABBqYXZhL2xhbmcvT2JqZWN0AQAGPGluaXQ+AQADKClWCAAIAQAOd3d3LndkYnl0ZS5jb20HAAoBABVjb20vd2RieXRlL0pFUDM3MVRlc3QBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAF0xjb20vd2RieXRlL0pFUDM3MVRlc3Q7AQAGbG9va3VwAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAApTb3VyY2VGaWxlAQAPSkVQMzcxVGVzdC5qYXZhACEACQACAAAAAAACAAEABQAGAAEACwAAAC8AAQABAAAABSq3AAGxAAAAAgAMAAAABgABAAAAAwANAAAADAABAAAABQAOAA8AAAAJABAAEQABAAsAAAAbAAEAAAAAAAMSB7AAAAABAAwAAAAGAAEAAAAEAAEAEgAAAAIAEw==&quot;; public static void main(String[] args) throws Throwable { byte[] classInBytes = Base64.getDecoder().decode(CLASS_INFO); Class&lt;?&gt; proxy = MethodHandles.lookup() .defineHiddenClass(classInBytes, true, MethodHandles.Lookup.ClassOption.NESTMATE) .lookupClass(); System.out.println(proxy.getName()); MethodHandle mh = MethodHandles.lookup().findStatic(proxy, &quot;lookup&quot;, MethodType.methodType(String.class)); String result = (String) mh.invokeExact(); System.out.println(result); } } 输出结果 com.wdbyte.JEP371Test/0x0000000800c01800 www.wdbyte.com JEP 378文本块 在这之前，如果我们把一个 JSON 赋值给字符串： String content = &quot;{\\n&quot; + &quot; \\&quot;upperSummary\\&quot;: null,\\n&quot; + &quot; \\&quot;sensitiveTypeList\\&quot;: null,\\n&quot; + &quot; \\&quot;gmtModified\\&quot;: \\&quot;2011-08-05 10:50:09\\&quot;,\\n&quot; + &quot; \\&quot;lowerGraph\\&quot;: null,\\n&quot; + &quot; \\&quot;signature\\&quot;: \\&quot;\\&quot;,\\n&quot; + &quot; \\&quot;appName\\&quot;: \\&quot;xxx\\&quot;,\\n&quot; + &quot; \\&quot;lowerSummary\\&quot;: null,\\n&quot; + &quot; \\&quot;gmtCreate\\&quot;: \\&quot;2011-08-05 10:50:09\\&quot;,\\n&quot; + &quot; \\&quot;type\\&quot;: \\&quot;CALL\\&quot;,\\n&quot; + &quot; \\&quot;name\\&quot;: \\&quot;xxxx\\&quot;,\\n&quot; + &quot; \\&quot;subType\\&quot;: \\&quot;yyy\\&quot;,\\n&quot; + &quot; \\&quot;id\\&quot;: 1,\\n&quot; + &quot; \\&quot;projectId\\&quot;: 1,\\n&quot; + &quot; \\&quot;status\\&quot;: 1\\n&quot; + &quot;}&quot;; 终于不用写丑陋的长字符串了，你可以使用文本块的方式定义字符串了。 String content2 = &quot;&quot;&quot; { &quot;upperSummary&quot;: null, &quot;sensitiveTypeList&quot;: null, &quot;gmtModified&quot;: &quot;2011-08-05 10:50:09&quot;, &quot;lowerGraph&quot;: null, &quot;signature&quot;: &quot;&quot;, &quot;appName&quot;: &quot;xxx&quot;, &quot;lowerSummary&quot;: null, &quot;gmtCreate&quot;: &quot;2011-08-05 10:50:09&quot;, &quot;type&quot;: &quot;CALL&quot;, &quot;name&quot;: &quot;xxxx&quot;, &quot;subType&quot;: &quot;yyy&quot;, &quot;id&quot;: 1, &quot;projectId&quot;: 1, &quot;status&quot;: 1 } &quot;&quot;&quot;; 两个特殊的转义符 \\ 结尾不换行 \\s 表示一个空格 示例：文本块体验 String content = &quot;&quot;&quot; { &quot;upperSummary&quot;: null,\\ &quot;sensitiveTypeList&quot;: null, &quot;gmtModified&quot;: &quot;2011-08-05\\s10:50:09&quot;, } &quot;&quot;&quot;; System.out.println(content); 输出结果： { &quot;upperSummary&quot;: null, &quot;sensitiveTypeList&quot;: null, &quot;gmtModified&quot;: &quot;2011-08-05 10:50:09&quot;, } JEP 390：基于值的类的警告 添加了一个注解，用于标识当前是是基于值的类，比如 Java 8 引入的预防空指针的 Optional 类，现在已经添加了注解标识。 @jdk.internal.ValueBased public final class Optional&lt;T&gt; { // ... } JEP 394：instanceof 模式匹配 在之前，使用 instanceof 需要如下操作： if (obj instanceof String) { String s = (String) obj; // grr... ... } 多余的类型强制转换，而现在： if (obj instanceof String s) { // Let pattern matching do the work! ... } JEP 395：Records record 是一种全新的类型，它本质上是一个 final 类，同时所有的属性都是 final 修饰，它会自动编译出 public get hashcode 、equals、toString 等方法，减少了代码编写量。 示例：编写一个 Dog record 类，定义 name 和 age 属性。 package com.wdbyte; public record Dog(String name, Integer age) { } Record 的使用。 package com.wdbyte; public class Java14Record { public static void main(String[] args) { Dog dog1 = new Dog(&quot;牧羊犬&quot;, 1); Dog dog2 = new Dog(&quot;田园犬&quot;, 2); Dog dog3 = new Dog(&quot;哈士奇&quot;, 3); System.out.println(dog1); System.out.println(dog2); System.out.println(dog3); } } 输出结果： Dog[name=牧羊犬, age=1] Dog[name=田园犬, age=2] Dog[name=哈士奇, age=3] JEP 306： 恢复始终严格的浮点语义 既然是恢复严格的浮点语义，那么说明在某个时间点之前，是始终严格的浮点语义的。其实在 Java SE 1.2 之前，所有的浮点计算都是严格的，但是以当初的情况来看，过于严格的浮点计算在当初流行的 x86 架构和 x87 浮点协议处理器上运行，需要大量的额外的指令开销，所以在 Java SE 1.2 开始，需要手动使用关键字 strictfp（strict float point） 才能启用严格的浮点计算。 但是在 2021 年的今天，硬件早已发生巨变，当初的问题已经不存在了，所以从 Java 17 开始，恢复了始终严格的浮点语义这一特性。 扩展：strictfp 是 Java 中的一个关键字，大多数人可能没有注意过它，它可以用在类、接口或者方法上，被 strictfp 修饰的部分中的 float 和 double 表达式会进行严格浮点计算。 下面是一个示例，其中的 testStrictfp() 被 strictfp 修饰。 package com.wdbyte; public class Main { public static void main(String[] args) { testStrictfp(); } public strictfp static void testStrictfp() { float aFloat = 0.6666666666666666666f; double aDouble = 0.88888888888888888d; double sum = aFloat + aDouble; System.out.println(&quot;sum: &quot; + sum); } } JEP 356：增强的伪随机数生成器 为伪随机数生成器 RPNG（pseudorandom number generator）增加了新的接口类型和实现，让在代码中使用各种 PRNG 算法变得容易许多。 这次增加了 RandomGenerator 接口，为所有的 PRNG 算法提供统一的 API，并且可以获取不同类型的 PRNG 对象流。同时也提供了一个新类 RandomGeneratorFactory 用于构造各种 RandomGenerator 实例，在 RandomGeneratorFactory 中使用 ServiceLoader.provider 来加载各种 PRNG 实现。 下面是一个使用示例：随便选择一个 PRNG 算法生成 5 个 10 以内的随机数。 package com.wdbyte.java17; import java.util.Date; import java.util.random.RandomGenerator; import java.util.random.RandomGeneratorFactory; import java.util.stream.Stream; /** * @author niulang */ public class JEP356 { public static void main(String[] args) { RandomGeneratorFactory&lt;RandomGenerator&gt; l128X256MixRandom = RandomGeneratorFactory.of(&quot;L128X256MixRandom&quot;); // 使用时间戳作为随机数种子 RandomGenerator randomGenerator = l128X256MixRandom.create(System.currentTimeMillis()); for (int i = 0; i &lt; 5; i++) { System.out.println(randomGenerator.nextInt(10)); } } } 得到输出： 7 3 4 4 6 你也可以遍历出所有的 PRNG 算法。 RandomGeneratorFactory.all().forEach(factory -&gt; { System.out.println(factory.group() + &quot;:&quot; + factory.name()); }); 得到输出： LXM:L32X64MixRandom LXM:L128X128MixRandom LXM:L64X128MixRandom Legacy:SecureRandom LXM:L128X1024MixRandom LXM:L64X128StarStarRandom Xoshiro:Xoshiro256PlusPlus LXM:L64X256MixRandom Legacy:Random Xoroshiro:Xoroshiro128PlusPlus LXM:L128X256MixRandom Legacy:SplittableRandom LXM:L64X1024MixRandom 可以看到 Legacy:Random 也在其中，新的 API 兼容了老的 Random 方式，所以你也可以使用新的 API 调用 Random 类生成随机数。 // 使用 Random RandomGeneratorFactory&lt;RandomGenerator&gt; l128X256MixRandom = RandomGeneratorFactory.of(&quot;Random&quot;); // 使用时间戳作为随机数种子 RandomGenerator randomGenerator = l128X256MixRandom.create(System.currentTimeMillis()); for (int i = 0; i &lt; 5; i++) { System.out.println(randomGenerator.nextInt(10)); } JEP 409：密封类（Sealed Classes） 我们都知道，在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 final 关键字对类进行修饰。不过这种要么可以继承，要么不能继承的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 sealed 类，被 sealed 修饰的类可以指定子类。这样这个类就只能被指定的类继承。 而且 sealed 修饰的类的机制具有传递性，它的子类必须使用指定的关键字进行修饰，且只能是 final、sealed、non-sealed 三者之一。 示例：犬类（Dog）只能被牧羊犬（Collie）和田园犬（TuGou）继承，使用 sealed 关键字。 package com.wdbyte; public sealed interface Dog permits Collie, TuGou { //... } 牧羊犬（Collie）只能被边境牧羊犬（BorderCollie）继承。 package com.wdbyte; /** * 牧羊犬 * @author www.wdbyte.com */ public sealed class Collie implements Dog permits BorderCollie { } 边境牧羊犬（BorderCollie）不能被继承，使用 final 关键字。 package com.wdbyte; /** * * @author www.wdbyte.com */ public final class BorderCollie extends Collie{ } 田园犬（ToGou）可以被任意继承，使用 non-sealed 关键字。 package com.wdbyte; /** * @author niulang */ public non-sealed class TuGou implements Dog { } JEP 415：指定上下文的反序列化过滤器 Java 中的序列化一直都是 非常重要的功能，如果没有序列化功能，Java 可能都不会占据开发语言的主导地位，序列化让远程处理变得容易和透明，同时也促进了 Java EE 的成功。 但是 Java 序列化的问题也很多，它几乎会犯下所有的可以想象的错误，为开发者带来持续的维护工作。但是要说明的是序列化的概念是没有错的，把对象转换为可以在 JVM 之间自由传输，并且可以在另一端重新构建的能力是完全合理的想法，问题在于 Java 中的序列化设计存在风险，以至于爆出过很多和序列化相关的漏洞。 反序列化危险的一个原因是，有时候我们不好验证将要进行反序列化的内容是否存在风险，而传入的数据流可以自由引用对象，很有可能这个数据流就是攻击者精心构造的恶意代码。 所以，JEP 415 允许在反序列化时，通过一个过滤配置，来告知本次反序列化允许或者禁止操作的类，反序列化时碰到被禁止的类，则会反序列化失败。 反序列化示例 假设 Dog 类中的 Poc 是恶意构造的类，但是正常反序列化是可以成功的。 package com.wdbyte.java17; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; /** * @author niulang */ public class JEP415 { public static void main(String[] args) throws IOException, ClassNotFoundException { Dog dog = new Dog(&quot;哈士奇&quot;); dog.setPoc(new Poc()); // 序列化 - 对象转字节数组 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);) { objectOutputStream.writeObject(dog); } byte[] bytes = byteArrayOutputStream.toByteArray(); // 反序列化 - 字节数组转对象 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object object = objectInputStream.readObject(); System.out.println(object.toString()); } } class Dog implements Serializable { private String name; private Poc poc; public Dog(String name) { this.name = name; } @Override public String toString() { return &quot;Dog{&quot; + &quot;name='&quot; + name + '\\'' + '}'; } // get...set... } class Poc implements Serializable{ } 输出结果： Dog{name='哈士奇'} 反序列化过滤器 在 Java 17 中可以自定义反序列化过滤器，拦截不允许的类。 package com.wdbyte.java17; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputFilter; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; /** * @author niulang */ public class JEP415 { public static void main(String[] args) throws IOException, ClassNotFoundException { Dog dog = new Dog(&quot;哈士奇&quot;); dog.setPoc(new Poc()); // 序列化 - 对象转字节数组 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);) { objectOutputStream.writeObject(dog); } byte[] bytes = byteArrayOutputStream.toByteArray(); // 反序列化 - 字节数组转对象 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); // 允许 com.wdbyte.java17.Dog 类，允许 java.base 中的所有类，拒绝其他任何类 ObjectInputFilter filter = ObjectInputFilter.Config.createFilter( &quot;com.wdbyte.java17.Dog;java.base/*;!*&quot;); objectInputStream.setObjectInputFilter(filter); Object object = objectInputStream.readObject(); System.out.println(object.toString()); } } class Dog implements Serializable { private String name; private Poc poc; public Dog(String name) { this.name = name; } @Override public String toString() { return &quot;Dog{&quot; + &quot;name='&quot; + name + '\\'' + '}'; } // get...set... } class Poc implements Serializable{ } 这时反序列化会得到异常。 Exception in thread &quot;main&quot; java.io.InvalidClassException: filter status: REJECTED at java.base/java.io.ObjectInputStream.filterCheck(ObjectInputStream.java:1412) at java.base/java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:2053) at java.base/java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1907) .... JEP 373：重新实现DatagramSocket API JEP374：禁用和废弃偏向锁（Biased Locking) 在之前，JVM 在处理同步操作，如使用 synchronized 同步时，有一套锁的升级机制，其中有一个锁机制就是偏向锁。然而通过目前的 Java 开发环境来看，使用这些被 synchronized 同步的类的机会并不多，如开发者更喜欢使用 HashMap 或者 ArrayList 而非 HashTable 和 Vector。 即使换个角度，当初使用偏向锁是为了提高性能，如今看来性能提升的程度和使用次数都不太有用。而偏向锁的引入增加了 JVM 的复杂性。 所以现在偏向锁被默认禁用，在不久的将来将会彻底删除 JEP 411：弃用 Security Manager Security Manager 在 JDK 1.0 时就已经引入，但是它一直都不是保护服务端以及客户端 Java 代码的主要手段，为了 Java 的继续发展，决定弃用 Security Manager，在不久的未来进行删除。 @Deprecated(since=&quot;17&quot;, forRemoval=true) public class SecurityManager { // ... } 其他 JEP 189: Shenandoah垃圾收集器 Java 12 增加了 Shenandoah 一个低停顿的垃圾收集器，它可以和 Java 应用程序中的执行线程同时进行，用来收集垃圾进行内容回收，这样就可以让停顿时间更少。 更多关于 Shenandoah 垃圾收集器的介绍可以查看文档：Shenandoah GC 介绍。 ZGC并发类卸载 Z 垃圾收集器现在支持类卸载，通过卸载不使用的类来释放这些类相关的数据结构，从而减少应用程序的总体占用空间。因为是并发执行，所以不会停止 Java 应用程序线程的执行，也因此对 GC 的暂停时间影响微乎其微。默认情况下启用此功能，但可以使用命令行选项禁用 -XX:-ClassUnloading。 JEP 334: JVM常量API 在包 java.lang.invoke.constant 中定义了一系列的基于值的符号引用，可以用来描述各种可加载常量。可以更容易的对关键类文件和运行时构建的名义描述进行建模，特别是对那些从常量池中加载的常量，也让开发者可以更简单标准的处理可加载常量。 JEP 314: 默认使用类数据共享(CDS) CDS 可以让 JVM 在同一台机器或虚拟机上启动多个应用的速度速度大大增加。原理是在启动应用时共享一些类加载信息，这样启动新进程时就可以使用共享的数据。在 Java 12 之前此功能需要手动开启，Java 12 调整为默认开启。 JEP 230: 微基准套件 Java 12 中添加一套新的基于 JMH 的基本的微基准测试套件。 JEP 350：动态CDS存档 JVM 启动时有一步是需要在内存中加载类，而如果有多个 jar，加载第一个 jar 的速度是最慢的。这就延长了程序的启动时间，为了减少这个时间，Java 10 引入了应用程序类数据共享（CDS）机制，它可以把你想共享的类共享在程序之间，使不同的 Java 进程之间共享这个类来减少这个类占用的空间以及加载速度。不过 Java 10 中使用这个功能的步骤比较繁琐。 而 Java 13 中的 AppCDS，允许 Java 应用在程序执行结束时（如果 JVM 没有崩溃）进行动态存档；存储的内容包括所有加载的应用类型类和使用的类库，这些存储的类库本来并不存在于默认的 CDS 存档中。 使用这个功能非常简单，只需要在程序启动时增加启动参数 。 # ArchiveClassesAtExit，程序结束时动态存档 bin/java -XX:ArchiveClassesAtExit=hello.jsa -cp hello.jar Hello # SharedArchiveFile，使用指定存档启动 bin/java -XX:SharedArchiveFile=hello.jsa -cp hello.jar Hello JEP 351：ZGC 归还未使用的内存（实验性） 在 Java 13 之前，ZGC 虽然在清理内存时导致的停顿时间非常少，但是即使内存已经长时间没有使用，ZGC 也不会将内存返还给操作系统，这对那些十分关注内存占用的应用程序非常不友好。 比如： 资源按使用量付费的云上容器环境。 应用虽然长时间闲置，但是占用了内存，导致运行的其他程序内存紧张。 而新增的这个功能，可以让 ZGC 归还长时间没有使用的内存给操作系统，这对某些用户来说十分友好。 JEP 345：G1支持NUMA（非统一内存访问） G1 收集器现在可以感知 NUMA 内存分配方式，以提高 G1 的性能，可以使用 +XX:+UseNUMA 启用这项功能。 JEP 363： 移除 CMS 垃圾收集器 移除对 CMS（Concurrent Mark Sweep） 垃圾收集器的支持，其实早在 Java 9 就开始移除 CMS 垃圾收集器了，只不过在 Java 14 中被正式删除。 JEP 364：macOS 上的 ZGC（实验性） Java 11 在 Linux 上引入了 Z 垃圾收集器 (ZGC)，现在它可以移植到 macOS。 JEP 365：Windows 上的 ZGC（实验性） Java 11 在 Linux 上引入了 Z 垃圾收集器 (ZGC)，现在它可以移植到 Windows 上（版本大于 1803）。 JEP 366：弃用 ParallelScavenge + SerialOld GC 组合 JEP 377：ZGC可扩展低延迟垃圾收集器 ZGC 垃圾收集器在 Java 11 中被引入，但是因为收集器的复杂性，当初决定逐渐引入。然后不断的听取用户的反馈建议修复问题。而现在，已经很久没有收到用户的问题反馈了，ZGC 是时候投入正式使用阶段了。所以在 Java 15 中 ZGC 正式发布，可以使用下面的参数启用 ZGC。 $ java -XX:+UseZGC className JEP 376：ZGC 并发线程堆栈处理 这次改动让 ZGC 线程堆栈处理从 安全点（Safepoints) 移动到并发阶段。 如果你忘记了什么是 Safepoints，可以复习一下。 我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 Stop The World。 而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做安全点（Safepoints）。 支持Unicode 11 在 Java 11 支持了 Unicode 10 之后， Java 12 支持了 Unicode 11，支持操作更多的表情、符号。 JEP 392：打包工具 在 Java 14 中，引入了打包工具，命令是 jpackage，使用 jpackage 命令可以把 JAR 包打包成不同操作系统支持的软件格式。 jpackage --name myapp --input lib --main-jar main.jar --main-class myapp.Main 常见平台格式如下： Linux: deb and rpm macOS: pkg and dmg Windows: msi and exe 要注意的是，jpackage 不支持交叉编译，也就是说在 windows 平台上是不能打包成 macOS 或者 Linux 系统的软件格式的。 下面是一个例子，把一个简单的 Java Swing 程序打包成当前操作系统支持的软件格式，然后安装到当前电脑。 编写 Java 代码 import javax.swing.*; import java.awt.*; public class JEP392 { public static void main(String[] args) { JFrame frame = new JFrame(&quot;Hello World Java Swing&quot;); frame.setMinimumSize(new Dimension(800, 600)); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JLabel lblText = new JLabel(&quot;Hello World!&quot;, SwingConstants.CENTER); frame.getContentPane().add(lblText); frame.pack(); frame.setVisible(true); } } 编译后，创建一个 JAR 文件。 $ javac JEP392.java $ java JEP392.java $ jar cvf JEP392.jar JEP392.class 将生成的 JEP392.jar 打包到符合当前平台的软件包中。 $ ~/develop/jdk-16.0.1.jdk/Contents/Home/bin/jpackage -i . -n JEP392 --main-jar hello.jar --main-class JEP392 $ ll -rw-r--r--@ 1 darcy staff 50M 10 28 20:34 JEP392-1.0.dmg -rw-r--r-- 1 darcy staff 864B 10 28 20:22 JEP392.class -rw-r--r-- 1 darcy staff 1.0K 10 28 20:30 JEP392.jar -rw-r--r-- 1 darcy staff 588B 10 28 20:22 JEP392.java ll 后显示的 JEP392-1.0.dmg（我用的 MacOS ，所以格式是 dmg）就是打包后的结果。 不同的系统安装位置不同： Linux： /opt MacOS ： /Applications Windows: C:\\Program Files\\ JEP 372：移除Nashorn JavaScript引擎 Nashorn JavaScript 引擎在 Java 8 中被引入，在 Java 11 中被标记为废弃。由于 ECMAScript 语言发展很快，维护 Nashorn JavaScript 的成本过于高昂，在 Java 15 中被彻底删除。 JEP 381: 删除Solaris和SPARC端口 JEP 385:废弃RMI激活机制 JEP 347: 启用C++14语言特性 这项更新和 Java 开发者关系不太密切，JEP 347 允许 在 JDK 的 C++ 源码中使用 C++ 14 的语言特性，并且给出了哪些特性可以在 HotSpot 代码中使用的具体说明。 JEP 357 在此之前，OpenJDK 源代码是使用版本管理工具 Mercurial 进行管理的，你也可以在 http://hg.openjdk.java.net/查看 OpenJDK 的源代码历史版本。 但是现在迁移到了 GIt ，主要原因如下： Mercurial 生成的版本控制元数据过大。 Mercurial 相关的开发工具比较少，而 Git 几乎在所有的主流 IDE 中已经无缝集成。 Mercurial 相关的服务比较少，无论是自建托管，还是服务托管。 为了优雅的迁移到 Git，OpenJDK 做了如下操作。 将所有的单存储库 OpenJDK 项目从 Mercurial 迁移到 Git。 保留所有的版本控制历史，也包括 Tag。 根据 Git 的最佳实践重新格式化提交的消息。 创建了一个工具用来在 Mercurial 和 Git 哈希之间进行转换。 JEP 369：迁移到 GitHub 和 JEP 357 从 Mercurial 迁移到 Git 的改变一致，在把版本管理迁移到 Git 之后，选择了在 GitHub 上托管 OpenJDK 社区的 Git 仓库。不过只对 JDK 11 以及更高版本 JDK 进行了迁移。 JEP 380：Unix 域套接字通道 添加 UnixDomainSocketAddress.java 类用于支持 Unix 域套接字通道。 添加 Unix-domain socket 到 SocketChannel 和 ServerSocketChannel API 中。 添加枚举信息 java.net.StandardProtocolFamily.UNIX。 JEP 386：移植 Alpine Linux Apine Linux 是一个独立的、非商业的 Linux 发行版，它十分的小，一个容器需要不超过 8MB 的空间，最小安装到磁盘只需要大约 130MB 存储空间，并且十分的简单，同时兼顾了安全性。 此提案将 JDK 移植到了 Apline Linux，由于 Apline Linux 是基于 musl lib 的轻量级 Linux 发行版，因此其他 x64 和 AArch64 架构上使用 musl lib 的 Linux 发行版也适用。 JEP 387：更好的 Metaspace 自从引入了 Metaspace 以来，根据反馈，Metaspace 经常占用过多的堆外内存，从而导致内存浪费，现在可以更及时地将未使用的 HotSpot class-metaspace 内存返还给操作系统，从而减少 Metaspace 的占用空间，并优化了 Metaspace 代码以降低后续的维护成本。 JEP 388：移植 Windows/AArch64 将 JDK 移植到 Windows/AArch64 架构上，Windows/AArch64 已经是终端用户市场的热门需求。 JEP 403：更强的 JDK 内部封装 为了提高 JDK 的安全性，使 --illegal-access 选项的默认模式从允许更改为拒绝。通过此更改，JDK 的内部包和 API（关键内部 API除外）将不再默认打开。 但是在 Java 17 中，除了 sun.misc.Unsafe ，使用 --illegal-access 命令也不能打开 JDK 内部的强封装模式了，除了 sun.misc.Unsafe API . 在 Java 17 中使用 --illegal-access 选项将会得到一个命令已经移除的警告。 ➜ bin ./java -version openjdk version &quot;17&quot; 2021-09-14 OpenJDK Runtime Environment (build 17+35-2724) OpenJDK 64-Bit Server VM (build 17+35-2724, mixed mode, sharing) ➜ bin ./java --illegal-access=warn OpenJDK 64-Bit Server VM warning: Ignoring option --illegal-access=warn; support was removed in 17.0 JEP 382：使用新的 macOS 渲染库 macOS 为了提高图形的渲染性能，在 2018 年 9 月抛弃了之前的 OpenGL 渲染库 ，而使用了 Apple Metal 进行代替。Java 17 这次更新开始支持 Apple Metal，不过对于 API 没有任何改变，这一些都是内部修改。 JEP 391：支持 macOS/AArch64 架构 起因是 Apple 在 2020 年 6 月的 WWDC 演讲中宣布，将开启一项长期的将 Macintosh 计算机系列从 x64 过度到 AArch64 的长期计划，因此需要尽快的让 JDK 支持 macOS/AArch64 。 JEP 398：删除已弃用的 Applet API Applet 是使用 Java 编写的可以嵌入到 HTML 中的小应用程序，嵌入方式是通过普通的 HTML 标记语法，由于早已过时，几乎没有场景在使用了。 示例：嵌入 Hello.class &lt;applet code=&quot;Hello.class&quot; height=200 width=200&gt;&lt;/applet&gt; Applet API 在 Java 9 时已经标记了废弃，现在 Java 17 中将彻底删除。 JEP 407：移除 RMI Activation 移除了在 JEP 385 中被标记废除的 RMI（Remote Method Invocation）Activation，但是 RMI 其他部分不会受影响。 JEP 410：移除实验性的 AOT 和 JIT 编译器 在 Java 9 的 JEP 295 中，引入了实验性的提前编译 jaotc 工具，但是这个特性自从引入依赖用处都不太大，而且需要大量的维护工作，所以在 Java 17 中决定删除这个特性。 主要移除了三个 JDK 模块： jdk.aot - jaotc 工具。 Jdk.internal.vm.compiler - Graal 编译器。 jdk.internal.vm.compiler.management 同时也移除了部分与 AOT 编译相关的 HotSpot 代码： src/hotspot/share/aot — dumps and loads AOT code Additional code guarded by #if INCLUDE_AOT ","link":"https://alexritian.github.io/post/java12-java17-xin-te-xing/"},{"title":"k8s打怪升级之路---第一关，搭建一个简单的","content":"使用kubeadm搭建一个简单的k8s集群 准备阶段 规划节点 准备linux服务器（配置随意，不能小于2C/2G 😜），规划哪些服务器作为master节点，那些作为node节点。 我准备了4台服务器,一台作为master节点，2台作为node节点,有一台不加入集群的服务器作为部署节点。 [!tip] 部署节点不是必须的，集群中的任何节点都可以执行部署操作 节点名字(可选) 给每个节点起名字，然后将其配置到每个服务器的 /etc/hosts [!tip] 默认Pod不会调度到master节点，只会在node节点调度 下载安装包 containerd containerd-releases : 从github现在最新release版本 containerd.service 文件 go.mod runc runc-releases cni-plugin plugins-releases 初始化脚本 cilium releases hlem releases go Download k9s release 安装组件 所有节点（服务器）都需要进行下列操作 [!tip] 有条件的使用 root 用户进行下列操作，非root用户也是可以的，只是我是使用root进行的操作 install go rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz 添加export PATH=$PATH:/usr/local/go/bin到/etc/profile source /etc/profile go version 执行下列命令 rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz 配置环境变量，添加下列内容到 /etc/profile export PATH=$PATH:/usr/local/go/bin 执行下列命令使环境变量生效 source /etc/profile 验证 go version install go mod [!attention] 我不懂GO，所以containerd go mod我是直接从github下载文件放到了go的目录中 😅 mkdir -p /usr/local/go/bin/src/github.com/containerd/containerd/ cp go.mod /usr/local/go/bin/src/github.com/containerd/containerd/ install containerd 解压[[#containerd|准备阶段]] 下载的 containerd-x.x.x-llinux-amd64.tar.gz 解压到 /usr/local 目录 tar Cxzvf /usr/local containerd-1.6.8-linux-amd64.tar.gz install runc 通过下列命令将[[#runc#|准备阶段]] 下载的runc.&lt;ARCH&gt; 安装到/user/sbin/ 目录 install -m 755 runc.amd64 /usr/sbin/runc install CNI plugin 通过下列命令将[[#cni-plugin|准备阶段]] 下载的 cni-plugins-xxx-xxx-vxxxx.tgz 解压到 /opt/cni/bin 目录 mkdir -p /opt/cni/bin tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz install kubeadm、kubelet 和 kubectl cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes sudo systemctl enable --now kubelet 进行配置 关闭swap 编辑 /etc/fstab 注释 swap 行 配置iptables cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # 设置所需的 sysctl 参数，参数在重新启动后保持不变 cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # 应用 sysctl 参数而不重新启动 sudo sysctl --system 配置containerd.service 将[[#准备阶段#containerd#|准备阶段]] 下载的containerd.service文件复制到/usr/lib/systemd/system/，然后执行下列命令： systemctl daemon-reload systemctl enable --now containerd 配置containerd 配置containerd.service 将[[#准备阶段#containerd#|准备阶段]] 下载的containerd.service文件复制到/usr/lib/systemd/system/，然后执行下列命令： systemctl daemon-reload systemctl enable --now containerd 通过下面命令生成containerd默认配置文件 containerd config default &gt; /etc/containerd/config.toml [!tip] 遇到no such file or directory: /etc/containerd/config.toml报错，通过下列命令创建目录 mkdir -p /etc/containerd/ 遇到command not found: containerd,查询 containerd位置 whereis containerd 结果输出containerd: /usr/local/bin/containerd，将输出目录添加到$PATH 配置国内镜像源 修改 /etc/containerd/config.toml 文件 修改sandbox_image的镜像 [plugins.&quot;io.containerd.grpc.v1.cri&quot;] sandbox_image = &quot;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6&quot; 修改registry的镜像源 [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;] endpoint = [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;, &quot;https://registry-1.docker.io&quot;] [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;] endpoint = [&quot;registry.aliyuncs.com/google_containers&quot;] [!tip] xxxx.mirror.aliyuncs.com 需要到阿里云注册获取，每个帐号有一个独立的地址。 配置 systemd cgroup 驱动 在 /etc/containerd/config.toml 中设置 SystemdCgroup 为 true [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options] SystemdCgroup = true 重启 congtainerd.service sudo systemctl restart containerd 初始化CNI 执行[[#cni-plugin|准备阶段]] 下载的初始化cni的脚本 启动阶段 master节点 初始化集群 [!tip] 如果规划的master节点有多个，只需要在第一个master节点进行初始化 通过下列命令初始化节点 kubeadm init \\ --control-plane-endpoint=&lt;domain name&gt; \\ --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \\ --token= &lt;token&gt; \\ --token-ttl=0 \\ --apiserver-advertise-address=&lt;master ip&gt; \\ --pod-network-cidr=10.0.0.0/16 \\ --node-name=master [!note] --control-plane-endopoint : 配置control plane的域名，如果没有配置dns，需要在每个服务器上配置 /etc/hosts --image-repository : 镜像源地址，我使用的阿里云的源 --token ：配置集群的token，其他节点加入集群的时候使用, 格式： &quot;[a-z0-9]{6}.[a-z0-9]{16}&quot; 不使用此参数会自动生成一个 --token-ttl : token过期时间（例如 1 s，2 m，3 h），默认为 24h0m0s。如果设置为 '0'，则令牌将永不过期。 --apiserver-advertise-address : master 节点的IP地址 --pod-nwework-cidr 这个是配置集群内部使用的网段 --node-name 节点的名字(可以不添加此参数，默认为服务器的hostname) 命令执行成功之后会有如下输出 Your Kubernetes control-plane has initialized successfully! To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join &lt;domain name&gt;:6443 --token &lt;token&gt; \\ --discovery-token-ca-cert-hash &lt;hash&gt; \\ --control-plane Then you can join any number of worker nodes by running the following on each as root: kubeadm join &lt;domain name&gt;:6443 --token &lt;token&gt; \\ --discovery-token-ca-cert-hash &lt;sh256&gt; [!tip] 输出中的jion命令，带有 --control-plane 参数的是添加master节点(管理节点)到集群中，另一个为添加node节点(work节点)到集群中。 生成cluster config文件 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config node节点 通过下列命令把node节点加入集群 kubeadm join \\ &lt;master domin name&gt;:6443 \\ --token &lt;token&gt; \\ --discovery-token-ca-cert-hash &lt;hash256&gt; \\ --node-name=node1 [!tip] &lt;master domain name&gt; : 初始化集群的时候配置的 --control-plane-endopoint 参数的值 --token : 初始化集群配置的token，直接复制初始化集群之后的输出内容中的 token使用即可 --discovery-token-ca-cert-hash : 直接复制初始化集群之后的输出内容中的 hash使用即可 --node-name : 节点的名字(可以不添加此参数，默认为服务器的hostname) 配置部署节点 copy cluster config文件到部署节点 mkdir -p $HOME/.kube cp config $HOME/.kube/ [!tipe] config文件来自master节点，目录在执行初始化集群操作的用户的 $HOME/.kube/ 目录 如果选择在执行初始化集群命令的服务器上进行部署操作，可以跳过这步。 如果选择在其他节点的服务器上进行部署操作，需要执行此步 install kubectl 参考 [[#install kubeadm、kubelet 和 kubectl|安装组件]] 安装kubectl install helm tar -zxvf helm-v3.0.0-linux-amd64.tar.gz mv linux-amd64/helm /usr/local/bin/helm [!tip] 有些虚机可能没有将 /usr/local/bin 目录加入到 $PATH install k9s 解压 copy k9s to /usr/local/bin 部署应用 网络组件 install cilium sudo tar xzvfC cilium-linux-${CLI_ARCH}.tar.gz /usr/local/bin cilium install 查看一下状态 cilium status 测试用例 部署busybox 创建一个 busybox.yaml 文件,将下列内容写入文件中 apiVersion: apps/v1 kind: ReplicaSet metadata: name: busybox labels: app: guestbook tier: busybox spec: replicas: 2 selector: matchLabels: tier: busybox template: metadata: labels: tier: busybox spec: containers: - name: busybox image: busybox:1.28 command: - sleep - &quot;3600&quot; imagePullPolicy: IfNotPresent restartPolicy: Always 执行下列命令，部署busybox到集群中 kubectl apply -f busybox.yaml 检查集群状态 通过k9s查看并测试集群 执行命令，进入k9s界面。 k9s 查看节点状态 按 ESC,然后 按 ：，然后输入 node, 然后按 Enter。 然后看看 STATUS 列是否都是 Ready。 查看 Pod状态 进入k9s之后，按：，然后输入 pods,然后按 enter ， 然后按 0,就可以看到类似下面的内容. 查看 READY 和 STATUS 是否正常。 [!info] k9s的详细操作，可以参考官网. 检查集群内部网络 通过方向键选中 busybox 的pod，NAME以 busybox开头。然后按 S 进入pod shell。 (需要提前记录一下另一个 busybox的 IP) [!tip] IP 列展示的是Pod在集群内部的IP地址 ping 10.0.0.44 -c 4 PING 10.0.0.44 (10.0.0.44): 56 data bytes 64 bytes from 10.0.0.44: seq=0 ttl=63 time=0.974 ms 64 bytes from 10.0.0.44: seq=1 ttl=63 time=0.684 ms 64 bytes from 10.0.0.44: seq=2 ttl=63 time=0.702 ms 64 bytes from 10.0.0.44: seq=3 ttl=63 time=0.659 ms --- 10.0.0.44 ping statistics --- 4 packets transmitted, 4 packets received, 0% packet loss 搞定 ","link":"https://alexritian.github.io/post/k8s-da-guai-sheng-ji-zhi-lu-di-yi-guan-da-jian-yi-ge-jian-dan-de/"}]}