---
toc_max_heading_level: 6
keywords: [linux, sudo]
tags: [linux]
---

ï¼šï¼šï¼štip Quote
At sunset my heart is still strong, though autumn winds loosen a failing frame. â€” *â€œJianghanâ€* Â· Du Fu, Tang Dynasty
ï¼šï¼šï¼š

<details>
  <summary>Full Text</summary>
A homesick traveler on the Yangtze and Han; a pedant adrift beneath heaven and earth.<br/>
A wisp of cloud, far as the sky; a lonely moon through an endless night.<br/>
At sunset my heart is still strong, though autumn winds loosen a failing frame.<br/>
Since ancient times, old horses have been keptâ€”no need to take the long road.  
</details>

---

## Exit `tmux`

There are several ways to exit a session in `tmux`, depending on whether you want to **close the entire session** or **only leave the current window/pane**:

---

### ğŸ§± 1) Exit the current pane

If you only want to leave the current shell (e.g., bash/zsh), simply type:

```bash
exit
```

Or use the shortcut:

```
Ctrl + D
```

ğŸ‘‰ If all panes in the current window are closed, that window will disappear automatically;
if all windows in the session are closed, `tmux` will exit automatically.

---

### ğŸªŸ 2) Close the entire window

Inside a tmux window, run:

```bash
exit
```

Or press:

```
Ctrl + D
```

Multiple times until the window is gone.
Or force close with the shortcut:

```
Ctrl + B  &   â†’ confirm y
```

This closes the current window.

---

### ğŸ§© 3) Kill the entire session

If you want to completely exit a `tmux` session (say itâ€™s called `my-session`):

```bash
tmux kill-session -t my-session
```

Or inside the session, press:

```
Ctrl + B  :kill-session
```

You can also list and close from outside:

```bash
tmux ls                 # list sessions
tmux kill-session -t 0  # kill session 0
```

---

### ğŸ’¡ 4) Detach temporarily (leave running)

If you just want to â€œhangâ€ tmux and come back later (keep programs running):

```
Ctrl + B  D
```

Youâ€™ll see:

```
[detached (from session 0)]
```

Reattach later with:

```bash
tmux attach -t 0
```

Or:

```bash
tmux a
```

---

### ğŸš€ 5) Kill all tmux sessions completely

If you want to â€œwipe outâ€ all tmux instances:

```bash
tmux kill-server
```

This terminates all sessions and processes.

---

Absolutely âœ…
Below is a version with headings starting from `##`, shifting all heading levels down by oneâ€”handy for dropping into a project doc hierarchy (e.g., under `docs/ansible/`).

---

## ğŸ§© Ansible Jinja2 Regex Handling & Exception-Safe Practices

### 1. Background

When writing Ansible Playbooks, we often need to auto-compute the next available index based on existing filenames, e.g.:

```
2025-10-22.tar.gz
2025-10-22-1.tar.gz
2025-10-22-2.tar.gz
```

Goal:

> If the file exists, automatically append an incrementing suffix (like `-1`, `-2`, `-3`) until itâ€™s unique.

Original idea:

```yaml
set_fact:
  nums: >-
    {{
      _found.files
      | map(attribute='path')
      | map('basename')
      | map('regex_search', '^' ~ _date ~ '(?:-(\\d+))?\\.tar\\.gz$', '\\1')
      | map('default', '0', true)
      | map('int')
      | list
    }}
  next_num: "{{ (nums | max) + 1 if (_found.matched | int) > 0 else 0 }}"
```

But it failed with:

```
'NoneType' object has no attribute 'group'
```

---

### 2. Root Cause Analysis

Jinja2â€™s `regex_search` returns **`None` when thereâ€™s no match**.
Subsequent operations like `map('int')` expect strings or numbers, not `None`, which triggers:

```
AttributeError: 'NoneType' object has no attribute 'group'
```

Even with `default('0', true)`, it only applies when a variable is **undefined**, not when itâ€™s `None`, so the error persists.

---

### 3. Correct Approach: Safe Regex + Filters

Use **`select('match')` + `regex_replace`** for safe handling.

```yaml
- name: Compute next available dest name (safe)
  ansible.builtin.set_fact:
    archive_dest: "{{ base_dir }}/{{ _date }}{{ suffix }}.tar.gz"
  vars:
    basenames: >-
      {{ _found.files | map(attribute='path') | map('basename') | list }}

    # Whether the base file (_date.tar.gz) exists
    base_exists: >-
      {{ basenames | select('equalto', _date ~ '.tar.gz') | list | length > 0 }}

    # Only select files matching "-number.tar.gz"
    numbers: >-
      {{
        basenames
        | select('match', '^' ~ _date ~ '-\\d+\\.tar\\.gz$')
        | map('regex_replace', '^' ~ _date ~ '-(\\d+)\\.tar\\.gz$', '\\1')
        | map('int')
        | list
      }}

    # Treat the base file as index 0
    taken: >-
      {{
        (base_exists | ternary([0], [])) + numbers
      }}

    # Max + 1
    next_num: >-
      {{ 0 if (taken | length) == 0 else (taken | max) + 1 }}

    # Build final filename suffix
    suffix: "{{ '' if next_num == 0 else '-' ~ next_num }}"
```

âœ… Key improvements:

* `select('match')` ensures regex ops only run on matching strings;
* `regex_replace` safely extracts digits;
* `ternary` merges the base-file index 0;
* Avoids `regex_search` entirely to prevent `NoneType` issues.

---

### 4. Execution Flow

| Step | Action                                    | Result                                         |
| ---- | ----------------------------------------- | ---------------------------------------------- |
| 1    | Read existing `.tar.gz` filenames         | `['2025-10-22.tar.gz', '2025-10-22-1.tar.gz']` |
| 2    | Check for â€œno-suffixâ€ base file           | `base_exists = true`                           |
| 3    | Extract numeric parts from suffixed files | `numbers = [1]`                                |
| 4    | Merge taken indices                       | `taken = [0,1]`                                |
| 5    | Max + 1                                   | `next_num = 2`                                 |
| 6    | Assemble suffix                           | `suffix = -2`                                  |
| 7    | Produce new filename                      | `2025-10-22-2.tar.gz`                          |

---

### 5. Jinja2 Regex Filter Reference

| Function                          | Description                    | Return                         |
| --------------------------------- | ------------------------------ | ------------------------------ |
| `regex_search(pattern, [group])`  | Find match and return group    | Returns `None` if no match     |
| `regex_replace(pattern, replace)` | Replace matched part           | Always returns a string        |
| `select('match', pattern)`        | Filter elements matching regex | Safely filters lists           |
| `map('int')`                      | Convert string to integer      | Valid only for numeric strings |

> ğŸš¨ Note: `regex_search` easily returns `None` on no-match; prefer `select('match')` before `regex_replace`.

---

### 6. Practical Tips

1. **Avoid chaining `regex_search` + `map('int')`**
   â†’ Filter first with `select('match')`.
2. **Use `ternary` and `default` for empty cases**
   Ensure safe defaults to avoid `max()` errors.
3. **Use `debug: var=` while testing**
   Inspect actual variable values to verify template logic.
4. **Follow â€œfilter â†’ extract â†’ convertâ€**
   Donâ€™t call string methods on `None`.

---

### 7. Full Task Context Example

```yaml
- name: Find existing archives for this date
  find:
    paths: "{{ base_dir }}"
    patterns: "{{ _date }}*.tar.gz"
    file_type: file
  register: _found

- name: Compute next available dest name (safe)
  set_fact:
    archive_dest: "{{ base_dir }}/{{ _date }}{{ suffix }}.tar.gz"
  vars:
    basenames: "{{ _found.files | map(attribute='path') | map('basename') | list }}"
    base_exists: "{{ basenames | select('equalto', _date ~ '.tar.gz') | list | length > 0 }}"
    numbers: >-
      {{
        basenames
        | select('match', '^' ~ _date ~ '-\\d+\\.tar\\.gz$')
        | map('regex_replace', '^' ~ _date ~ '-(\\d+)\\.tar\\.gz$', '\\1')
        | map('int')
        | list
      }}
    taken: "{{ (base_exists | ternary([0], [])) + numbers }}"
    next_num: "{{ 0 if (taken | length) == 0 else (taken | max) + 1 }}"
    suffix: "{{ '' if next_num == 0 else '-' ~ next_num }}"

- name: Compress the files
  archive:
    path: "{{ base_dir }}/{{ _date }}"
    dest: "{{ archive_dest }}"
    format: gz
    remove: true
```

---

### 8. Quick Reference

| Topic                          | Key Point                                              |
| ------------------------------ | ------------------------------------------------------ |
| **Jinja2 template exceptions** | `regex_search` returns `None` â†’ chained ops fail       |
| **Solution**                   | Filter first (`select('match')`), then `regex_replace` |
| **Empty results**              | Use `ternary` or `default` for safe defaults           |
| **Extract digits**             | `regex_replace` + capture groups is robust             |
| **Auto-numbering**             | Use `max()+1`, or loop to find gaps (as needed)        |
| **Debugging**                  | `- debug: var=...` to inspect rendered values          |

---

### 9. Further Reading

* [Ansible Docs â€” Jinja2 Filters](https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html)
* [Jinja2 Docs â€” Regex Filters](https://jinja.palletsprojects.com/en/latest/templates/#regex)
* [Ansible Best Practices â€” Template Resilience](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_best_practices.html)

---

### ğŸ”š 10. Summary

| Concept             | Error Cause                  | Fix Approach                           |
| ------------------- | ---------------------------- | -------------------------------------- |
| `regex_search`      | Returns `None` when no match | Filter first with `select('match')`    |
| `max()` on empty    | Empty list raises error      | Provide default `[0]` or use `ternary` |
| String â†’ number     | `None` canâ€™t be `int`        | Filter before conversion               |
| Template robustness | Donâ€™t assume perfect input   | Use defaults and type-safe ops         |

âœ… **Best-practice pipeline:**

> **Filter â†’ Extract â†’ Convert â†’ Aggregate â†’ Concatenate**
> Ensure no input path can trigger an exception.
